import "./chunk-J43GMYXM.js";

// ../../node_modules/.pnpm/@algolia+predict@1.0.0-alpha.26/node_modules/@algolia/predict/dist/predict.esm.browser.js
function createAuth(appId, apiKey, authMode = "WithinHeaders") {
  const credentials = {
    "x-algolia-api-key": apiKey,
    "x-algolia-application-id": appId
  };
  return {
    headers() {
      return authMode === "WithinHeaders" ? credentials : {};
    },
    queryParameters() {
      return authMode === "WithinQueryParameters" ? credentials : {};
    }
  };
}
function createBrowserLocalStorageCache(options) {
  let storage;
  const namespaceKey = `algolia-client-js-${options.key}`;
  function getStorage() {
    if (storage === void 0) {
      storage = options.localStorage || window.localStorage;
    }
    return storage;
  }
  function getNamespace() {
    return JSON.parse(getStorage().getItem(namespaceKey) || "{}");
  }
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      return Promise.resolve().then(() => {
        const keyAsString = JSON.stringify(key);
        const value = getNamespace()[keyAsString];
        return Promise.all([value || defaultValue(), value !== void 0]);
      }).then(([value, exists]) => {
        return Promise.all([value, exists || events.miss(value)]);
      }).then(([value]) => value);
    },
    set(key, value) {
      return Promise.resolve().then(() => {
        const namespace = getNamespace();
        namespace[JSON.stringify(key)] = value;
        getStorage().setItem(namespaceKey, JSON.stringify(namespace));
        return value;
      });
    },
    delete(key) {
      return Promise.resolve().then(() => {
        const namespace = getNamespace();
        delete namespace[JSON.stringify(key)];
        getStorage().setItem(namespaceKey, JSON.stringify(namespace));
      });
    },
    clear() {
      return Promise.resolve().then(() => {
        getStorage().removeItem(namespaceKey);
      });
    }
  };
}
function createNullCache() {
  return {
    get(_key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      const value = defaultValue();
      return value.then((result) => Promise.all([result, events.miss(result)])).then(([result]) => result);
    },
    set(_key, value) {
      return Promise.resolve(value);
    },
    delete(_key) {
      return Promise.resolve();
    },
    clear() {
      return Promise.resolve();
    }
  };
}
function createFallbackableCache(options) {
  const caches = [...options.caches];
  const current = caches.shift();
  if (current === void 0) {
    return createNullCache();
  }
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      return current.get(key, defaultValue, events).catch(() => {
        return createFallbackableCache({
          caches
        }).get(key, defaultValue, events);
      });
    },
    set(key, value) {
      return current.set(key, value).catch(() => {
        return createFallbackableCache({
          caches
        }).set(key, value);
      });
    },
    delete(key) {
      return current.delete(key).catch(() => {
        return createFallbackableCache({
          caches
        }).delete(key);
      });
    },
    clear() {
      return current.clear().catch(() => {
        return createFallbackableCache({
          caches
        }).clear();
      });
    }
  };
}
function createMemoryCache(options = {
  serializable: true
}) {
  let cache = {};
  return {
    get(key, defaultValue, events = {
      miss: () => Promise.resolve()
    }) {
      const keyAsString = JSON.stringify(key);
      if (keyAsString in cache) {
        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);
      }
      const promise = defaultValue();
      return promise.then((value) => events.miss(value)).then(() => promise);
    },
    set(key, value) {
      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;
      return Promise.resolve(value);
    },
    delete(key) {
      delete cache[JSON.stringify(key)];
      return Promise.resolve();
    },
    clear() {
      cache = {};
      return Promise.resolve();
    }
  };
}
var EXPIRATION_DELAY = 2 * 60 * 1e3;
function createStatefulHost(host, status = "up") {
  const lastUpdate = Date.now();
  function isUp() {
    return status === "up" || Date.now() - lastUpdate > EXPIRATION_DELAY;
  }
  function isTimedOut() {
    return status === "timed out" && Date.now() - lastUpdate <= EXPIRATION_DELAY;
  }
  return {
    ...host,
    status,
    lastUpdate,
    isUp,
    isTimedOut
  };
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AlgoliaError = class extends Error {
  constructor(message, name) {
    super(message);
    _defineProperty(this, "name", "AlgoliaError");
    if (name) {
      this.name = name;
    }
  }
};
var ErrorWithStackTrace = class extends AlgoliaError {
  constructor(message, stackTrace, name) {
    super(message, name);
    _defineProperty(this, "stackTrace", void 0);
    this.stackTrace = stackTrace;
  }
};
var RetryError = class extends ErrorWithStackTrace {
  constructor(stackTrace) {
    super("Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.", stackTrace, "RetryError");
  }
};
var ApiError = class extends ErrorWithStackTrace {
  constructor(message, status, stackTrace) {
    super(message, stackTrace, "ApiError");
    _defineProperty(this, "status", void 0);
    this.status = status;
  }
};
var DeserializationError = class extends AlgoliaError {
  constructor(message, response) {
    super(message, "DeserializationError");
    _defineProperty(this, "response", void 0);
    this.response = response;
  }
};
function serializeUrl(host, path, queryParameters) {
  const queryParametersAsString = serializeQueryParameters(queryParameters);
  let url = `${host.protocol}://${host.url}/${path.charAt(0) === "/" ? path.substr(1) : path}`;
  if (queryParametersAsString.length) {
    url += `?${queryParametersAsString}`;
  }
  return url;
}
function serializeQueryParameters(parameters) {
  const isObjectOrArray = (value) => Object.prototype.toString.call(value) === "[object Object]" || Object.prototype.toString.call(value) === "[object Array]";
  return Object.keys(parameters).map((key) => `${key}=${encodeURIComponent(isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key])}`).join("&");
}
function serializeData(request, requestOptions) {
  if (request.method === "GET" || request.data === void 0 && requestOptions.data === void 0) {
    return void 0;
  }
  const data = Array.isArray(request.data) ? request.data : {
    ...request.data,
    ...requestOptions.data
  };
  return JSON.stringify(data);
}
function serializeHeaders(baseHeaders, requestHeaders, requestOptionsHeaders) {
  const headers = {
    Accept: "application/json",
    ...baseHeaders,
    ...requestHeaders,
    ...requestOptionsHeaders
  };
  const serializedHeaders = {};
  Object.keys(headers).forEach((header) => {
    const value = headers[header];
    serializedHeaders[header.toLowerCase()] = value;
  });
  return serializedHeaders;
}
function deserializeSuccess(response) {
  try {
    return JSON.parse(response.content);
  } catch (e) {
    throw new DeserializationError(e.message, response);
  }
}
function deserializeFailure({
  content,
  status
}, stackFrame) {
  let message = content;
  try {
    message = JSON.parse(content).message;
  } catch (e) {
  }
  return new ApiError(message, status, stackFrame);
}
function isNetworkError({
  isTimedOut,
  status
}) {
  return !isTimedOut && ~~status === 0;
}
function isRetryable({
  isTimedOut,
  status
}) {
  return isTimedOut || isNetworkError({
    isTimedOut,
    status
  }) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;
}
function isSuccess({
  status
}) {
  return ~~(status / 100) === 2;
}
function stackTraceWithoutCredentials(stackTrace) {
  return stackTrace.map((stackFrame) => stackFrameWithoutCredentials(stackFrame));
}
function stackFrameWithoutCredentials(stackFrame) {
  const modifiedHeaders = stackFrame.request.headers["x-algolia-api-key"] ? {
    "x-algolia-api-key": "*****"
  } : {};
  return {
    ...stackFrame,
    request: {
      ...stackFrame.request,
      headers: {
        ...stackFrame.request.headers,
        ...modifiedHeaders
      }
    }
  };
}
function createTransporter({
  hosts,
  hostsCache,
  baseHeaders,
  baseQueryParameters,
  algoliaAgent,
  timeouts,
  requester,
  requestsCache,
  responsesCache
}) {
  async function createRetryableOptions(compatibleHosts) {
    const statefulHosts = await Promise.all(compatibleHosts.map((compatibleHost) => {
      return hostsCache.get(compatibleHost, () => {
        return Promise.resolve(createStatefulHost(compatibleHost));
      });
    }));
    const hostsUp = statefulHosts.filter((host) => host.isUp());
    const hostsTimedOut = statefulHosts.filter((host) => host.isTimedOut());
    const hostsAvailable = [...hostsUp, ...hostsTimedOut];
    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;
    return {
      hosts: compatibleHostsAvailable,
      getTimeout(timeoutsCount, baseTimeout) {
        const timeoutMultiplier = hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;
        return timeoutMultiplier * baseTimeout;
      }
    };
  }
  async function retryableRequest(request, requestOptions, isRead = true) {
    const stackTrace = [];
    const data = serializeData(request, requestOptions);
    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);
    const dataQueryParameters = request.method === "GET" ? {
      ...request.data,
      ...requestOptions.data
    } : {};
    const queryParameters = {
      "x-algolia-agent": algoliaAgent.value,
      ...baseQueryParameters,
      ...request.queryParameters,
      ...dataQueryParameters
    };
    if (requestOptions && requestOptions.queryParameters) {
      for (const key of Object.keys(requestOptions.queryParameters)) {
        if (!requestOptions.queryParameters[key] || Object.prototype.toString.call(requestOptions.queryParameters[key]) === "[object Object]") {
          queryParameters[key] = requestOptions.queryParameters[key];
        } else {
          queryParameters[key] = requestOptions.queryParameters[key].toString();
        }
      }
    }
    let timeoutsCount = 0;
    const retry = async (retryableHosts, getTimeout) => {
      const host = retryableHosts.pop();
      if (host === void 0) {
        throw new RetryError(stackTraceWithoutCredentials(stackTrace));
      }
      let responseTimeout = requestOptions.timeout;
      if (responseTimeout === void 0) {
        responseTimeout = isRead ? timeouts.read : timeouts.write;
      }
      const payload = {
        data,
        headers,
        method: request.method,
        url: serializeUrl(host, request.path, queryParameters),
        connectTimeout: getTimeout(timeoutsCount, timeouts.connect),
        responseTimeout: getTimeout(timeoutsCount, responseTimeout)
      };
      const pushToStackTrace = (response2) => {
        const stackFrame = {
          request: payload,
          response: response2,
          host,
          triesLeft: retryableHosts.length
        };
        stackTrace.push(stackFrame);
        return stackFrame;
      };
      const response = await requester.send(payload);
      if (isRetryable(response)) {
        const stackFrame = pushToStackTrace(response);
        if (response.isTimedOut) {
          timeoutsCount++;
        }
        console.log("Retryable failure", stackFrameWithoutCredentials(stackFrame));
        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? "timed out" : "down"));
        return retry(retryableHosts, getTimeout);
      }
      if (isSuccess(response)) {
        return deserializeSuccess(response);
      }
      pushToStackTrace(response);
      throw deserializeFailure(response, stackTrace);
    };
    const compatibleHosts = hosts.filter((host) => host.accept === "readWrite" || (isRead ? host.accept === "read" : host.accept === "write"));
    const options = await createRetryableOptions(compatibleHosts);
    return retry([...options.hosts].reverse(), options.getTimeout);
  }
  function createRequest(request, requestOptions = {}) {
    const isRead = request.useReadTransporter || request.method === "GET";
    if (!isRead) {
      return retryableRequest(request, requestOptions, isRead);
    }
    const createRetryableRequest = () => {
      return retryableRequest(request, requestOptions);
    };
    const cacheable = requestOptions.cacheable || request.cacheable;
    if (cacheable !== true) {
      return createRetryableRequest();
    }
    const key = {
      request,
      requestOptions,
      transporter: {
        queryParameters: baseQueryParameters,
        headers: baseHeaders
      }
    };
    return responsesCache.get(key, () => {
      return requestsCache.get(key, () => requestsCache.set(key, createRetryableRequest()).then((response) => Promise.all([requestsCache.delete(key), response]), (err) => Promise.all([requestsCache.delete(key), Promise.reject(err)])).then(([_, response]) => response));
    }, {
      miss: (response) => responsesCache.set(key, response)
    });
  }
  return {
    hostsCache,
    requester,
    timeouts,
    algoliaAgent,
    baseHeaders,
    baseQueryParameters,
    hosts,
    request: createRequest,
    requestsCache,
    responsesCache
  };
}
function createAlgoliaAgent(version) {
  const algoliaAgent = {
    value: `Algolia for JavaScript (${version})`,
    add(options) {
      const addedAlgoliaAgent = `; ${options.segment}${options.version !== void 0 ? ` (${options.version})` : ""}`;
      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {
        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;
      }
      return algoliaAgent;
    }
  };
  return algoliaAgent;
}
function getAlgoliaAgent({
  algoliaAgents,
  client,
  version
}) {
  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({
    segment: client,
    version
  });
  algoliaAgents.forEach((algoliaAgent) => defaultAlgoliaAgent.add(algoliaAgent));
  return defaultAlgoliaAgent;
}
var DEFAULT_CONNECT_TIMEOUT_BROWSER = 1e3;
var DEFAULT_READ_TIMEOUT_BROWSER = 2e3;
var DEFAULT_WRITE_TIMEOUT_BROWSER = 3e4;
function createXhrRequester() {
  function send(request) {
    return new Promise((resolve) => {
      const baseRequester = new XMLHttpRequest();
      baseRequester.open(request.method, request.url, true);
      Object.keys(request.headers).forEach((key) => baseRequester.setRequestHeader(key, request.headers[key]));
      const createTimeout = (timeout, content) => {
        return setTimeout(() => {
          baseRequester.abort();
          resolve({
            status: 0,
            content,
            isTimedOut: true
          });
        }, timeout);
      };
      const connectTimeout = createTimeout(request.connectTimeout, "Connection timeout");
      let responseTimeout;
      baseRequester.onreadystatechange = () => {
        if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === void 0) {
          clearTimeout(connectTimeout);
          responseTimeout = createTimeout(request.responseTimeout, "Socket timeout");
        }
      };
      baseRequester.onerror = () => {
        if (baseRequester.status === 0) {
          clearTimeout(connectTimeout);
          clearTimeout(responseTimeout);
          resolve({
            content: baseRequester.responseText || "Network request failed",
            status: baseRequester.status,
            isTimedOut: false
          });
        }
      };
      baseRequester.onload = () => {
        clearTimeout(connectTimeout);
        clearTimeout(responseTimeout);
        resolve({
          content: baseRequester.responseText,
          status: baseRequester.status,
          isTimedOut: false
        });
      };
      baseRequester.send(request.data);
    });
  }
  return { send };
}
var apiClientVersion = "1.0.0-alpha.26";
var REGIONS = ["eu", "us"];
function getDefaultHosts(region) {
  const url = "predict.{region}.algolia.com".replace("{region}", region);
  return [{ url, accept: "readWrite", protocol: "https" }];
}
function createPredictClient({ appId: appIdOption, apiKey: apiKeyOption, authMode, algoliaAgents, region: regionOption, ...options }) {
  const auth = createAuth(appIdOption, apiKeyOption, authMode);
  const transporter = createTransporter({
    hosts: getDefaultHosts(regionOption),
    ...options,
    algoliaAgent: getAlgoliaAgent({
      algoliaAgents,
      client: "Predict",
      version: apiClientVersion
    }),
    baseHeaders: {
      "content-type": "text/plain",
      ...auth.headers(),
      ...options.baseHeaders
    },
    baseQueryParameters: {
      ...auth.queryParameters(),
      ...options.baseQueryParameters
    }
  });
  return {
    transporter,
    appId: appIdOption,
    clearCache() {
      return Promise.all([
        transporter.requestsCache.clear(),
        transporter.responsesCache.clear()
      ]).then(() => void 0);
    },
    get _ua() {
      return transporter.algoliaAgent.value;
    },
    addAlgoliaAgent(segment, version) {
      transporter.algoliaAgent.add({ segment, version });
    },
    activateModelInstance(activateModelParams, requestOptions) {
      if (!activateModelParams) {
        throw new Error("Parameter `activateModelParams` is required when calling `activateModelInstance`.");
      }
      if (!activateModelParams.type) {
        throw new Error("Parameter `activateModelParams.type` is required when calling `activateModelInstance`.");
      }
      if (!activateModelParams.name) {
        throw new Error("Parameter `activateModelParams.name` is required when calling `activateModelInstance`.");
      }
      if (!activateModelParams.sourceID) {
        throw new Error("Parameter `activateModelParams.sourceID` is required when calling `activateModelInstance`.");
      }
      if (!activateModelParams.index) {
        throw new Error("Parameter `activateModelParams.index` is required when calling `activateModelInstance`.");
      }
      const requestPath = "/1/predict/models";
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: activateModelParams
      };
      return transporter.request(request, requestOptions);
    },
    createSegment(createSegmentParams, requestOptions) {
      if (!createSegmentParams) {
        throw new Error("Parameter `createSegmentParams` is required when calling `createSegment`.");
      }
      if (!createSegmentParams.name) {
        throw new Error("Parameter `createSegmentParams.name` is required when calling `createSegment`.");
      }
      if (!createSegmentParams.conditions) {
        throw new Error("Parameter `createSegmentParams.conditions` is required when calling `createSegment`.");
      }
      const requestPath = "/1/segments";
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: createSegmentParams
      };
      return transporter.request(request, requestOptions);
    },
    del({ path, parameters }, requestOptions) {
      if (!path) {
        throw new Error("Parameter `path` is required when calling `del`.");
      }
      const requestPath = "/1{path}".replace("{path}", path);
      const headers = {};
      const queryParameters = parameters ? parameters : {};
      const request = {
        method: "DELETE",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    deleteModelInstance({ modelID }, requestOptions) {
      if (!modelID) {
        throw new Error("Parameter `modelID` is required when calling `deleteModelInstance`.");
      }
      const requestPath = "/1/predict/models/{modelID}".replace("{modelID}", encodeURIComponent(modelID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "DELETE",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    deleteSegment({ segmentID }, requestOptions) {
      if (!segmentID) {
        throw new Error("Parameter `segmentID` is required when calling `deleteSegment`.");
      }
      const requestPath = "/1/segments/{segmentID}".replace("{segmentID}", encodeURIComponent(segmentID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "DELETE",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    deleteUserProfile({ userID }, requestOptions) {
      if (!userID) {
        throw new Error("Parameter `userID` is required when calling `deleteUserProfile`.");
      }
      const requestPath = "/1/users/{userID}".replace("{userID}", encodeURIComponent(userID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "DELETE",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    fetchAllSegments({ type } = {}, requestOptions = void 0) {
      const requestPath = "/1/segments";
      const headers = {};
      const queryParameters = {};
      if (type !== void 0) {
        queryParameters.type = type.toString();
      }
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    fetchAllUserProfiles(fetchAllUserProfilesParams, requestOptions) {
      if (!fetchAllUserProfilesParams) {
        throw new Error("Parameter `fetchAllUserProfilesParams` is required when calling `fetchAllUserProfiles`.");
      }
      const requestPath = "/1/users";
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: fetchAllUserProfilesParams
      };
      return transporter.request(request, requestOptions);
    },
    fetchSegment({ segmentID }, requestOptions) {
      if (!segmentID) {
        throw new Error("Parameter `segmentID` is required when calling `fetchSegment`.");
      }
      const requestPath = "/1/segments/{segmentID}".replace("{segmentID}", encodeURIComponent(segmentID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    fetchUserProfile({ userID, params }, requestOptions) {
      if (!userID) {
        throw new Error("Parameter `userID` is required when calling `fetchUserProfile`.");
      }
      if (!params) {
        throw new Error("Parameter `params` is required when calling `fetchUserProfile`.");
      }
      const requestPath = "/1/users/{userID}/fetch".replace("{userID}", encodeURIComponent(userID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: params
      };
      return transporter.request(request, requestOptions);
    },
    get({ path, parameters }, requestOptions) {
      if (!path) {
        throw new Error("Parameter `path` is required when calling `get`.");
      }
      const requestPath = "/1{path}".replace("{path}", path);
      const headers = {};
      const queryParameters = parameters ? parameters : {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    getAvailableModelTypes(requestOptions) {
      const requestPath = "/1/predict/modeltypes";
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    getModelInstanceConfig({ modelID }, requestOptions) {
      if (!modelID) {
        throw new Error("Parameter `modelID` is required when calling `getModelInstanceConfig`.");
      }
      const requestPath = "/1/predict/models/{modelID}".replace("{modelID}", encodeURIComponent(modelID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    getModelInstances(requestOptions) {
      const requestPath = "/1/predict/models";
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    getModelMetrics({ modelID }, requestOptions) {
      if (!modelID) {
        throw new Error("Parameter `modelID` is required when calling `getModelMetrics`.");
      }
      const requestPath = "/1/predict/models/{modelID}/metrics".replace("{modelID}", encodeURIComponent(modelID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "GET",
        path: requestPath,
        queryParameters,
        headers
      };
      return transporter.request(request, requestOptions);
    },
    getSegmentUsers({ segmentID, fetchAllUserProfilesParams }, requestOptions) {
      if (!segmentID) {
        throw new Error("Parameter `segmentID` is required when calling `getSegmentUsers`.");
      }
      if (!fetchAllUserProfilesParams) {
        throw new Error("Parameter `fetchAllUserProfilesParams` is required when calling `getSegmentUsers`.");
      }
      const requestPath = "/1/segments/{segmentID}/users".replace("{segmentID}", encodeURIComponent(segmentID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: fetchAllUserProfilesParams
      };
      return transporter.request(request, requestOptions);
    },
    post({ path, parameters, body }, requestOptions) {
      if (!path) {
        throw new Error("Parameter `path` is required when calling `post`.");
      }
      const requestPath = "/1{path}".replace("{path}", path);
      const headers = {};
      const queryParameters = parameters ? parameters : {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {}
      };
      return transporter.request(request, requestOptions);
    },
    put({ path, parameters, body }, requestOptions) {
      if (!path) {
        throw new Error("Parameter `path` is required when calling `put`.");
      }
      const requestPath = "/1{path}".replace("{path}", path);
      const headers = {};
      const queryParameters = parameters ? parameters : {};
      const request = {
        method: "PUT",
        path: requestPath,
        queryParameters,
        headers,
        data: body ? body : {}
      };
      return transporter.request(request, requestOptions);
    },
    updateModelInstance({ modelID, updateModelParams }, requestOptions) {
      if (!modelID) {
        throw new Error("Parameter `modelID` is required when calling `updateModelInstance`.");
      }
      if (!updateModelParams) {
        throw new Error("Parameter `updateModelParams` is required when calling `updateModelInstance`.");
      }
      if (!updateModelParams.name) {
        throw new Error("Parameter `updateModelParams.name` is required when calling `updateModelInstance`.");
      }
      const requestPath = "/1/predict/models/{modelID}".replace("{modelID}", encodeURIComponent(modelID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: updateModelParams
      };
      return transporter.request(request, requestOptions);
    },
    updateSegment({ segmentID, updateSegmentParams }, requestOptions) {
      if (!segmentID) {
        throw new Error("Parameter `segmentID` is required when calling `updateSegment`.");
      }
      if (!updateSegmentParams) {
        throw new Error("Parameter `updateSegmentParams` is required when calling `updateSegment`.");
      }
      const requestPath = "/1/segments/{segmentID}".replace("{segmentID}", encodeURIComponent(segmentID));
      const headers = {};
      const queryParameters = {};
      const request = {
        method: "POST",
        path: requestPath,
        queryParameters,
        headers,
        data: updateSegmentParams
      };
      return transporter.request(request, requestOptions);
    }
  };
}
function predictClient(appId, apiKey, region, options) {
  if (!appId || typeof appId !== "string") {
    throw new Error("`appId` is missing.");
  }
  if (!apiKey || typeof apiKey !== "string") {
    throw new Error("`apiKey` is missing.");
  }
  if (!region || region && (typeof region !== "string" || !REGIONS.includes(region))) {
    throw new Error(`\`region\` is required and must be one of the following: ${REGIONS.join(", ")}`);
  }
  return createPredictClient({
    appId,
    apiKey,
    region,
    timeouts: {
      connect: DEFAULT_CONNECT_TIMEOUT_BROWSER,
      read: DEFAULT_READ_TIMEOUT_BROWSER,
      write: DEFAULT_WRITE_TIMEOUT_BROWSER
    },
    requester: createXhrRequester(),
    algoliaAgents: [{ segment: "Browser" }],
    authMode: "WithinQueryParameters",
    responsesCache: createMemoryCache(),
    requestsCache: createMemoryCache({ serializable: false }),
    hostsCache: createFallbackableCache({
      caches: [
        createBrowserLocalStorageCache({ key: `${apiClientVersion}-${appId}` }),
        createMemoryCache()
      ]
    }),
    ...options
  });
}
export {
  apiClientVersion,
  predictClient
};
//# sourceMappingURL=@algolia_predict.js.map
