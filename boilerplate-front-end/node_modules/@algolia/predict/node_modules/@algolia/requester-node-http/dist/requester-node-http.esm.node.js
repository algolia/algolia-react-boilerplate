import { URL } from 'url';
import { createEchoRequester } from '@algolia/client-common';
import http from 'http';
import https from 'https';

function echoRequester(status = 200) {
    return createEchoRequester({ getURL: (url) => new URL(url), status });
}

// Global agents allow us to reuse the TCP protocol with multiple clients
const agentOptions = { keepAlive: true };
const defaultHttpAgent = new http.Agent(agentOptions);
const defaultHttpsAgent = new https.Agent(agentOptions);
function createHttpRequester({ agent: userGlobalAgent, httpAgent: userHttpAgent, httpsAgent: userHttpsAgent, requesterOptions = {}, } = {}) {
    const httpAgent = userHttpAgent || userGlobalAgent || defaultHttpAgent;
    const httpsAgent = userHttpsAgent || userGlobalAgent || defaultHttpsAgent;
    function send(request) {
        return new Promise((resolve) => {
            let responseTimeout;
            // eslint-disable-next-line prefer-const -- linter thinks this is not reassigned
            let connectTimeout;
            const url = new URL(request.url);
            const path = url.search === null ? url.pathname : `${url.pathname}${url.search}`;
            const options = {
                agent: url.protocol === 'https:' ? httpsAgent : httpAgent,
                hostname: url.hostname,
                path,
                method: request.method,
                ...requesterOptions,
                headers: {
                    ...request.headers,
                    ...requesterOptions.headers,
                },
            };
            if (url.port && !requesterOptions.port) {
                options.port = url.port;
            }
            const req = (url.protocol === 'https:' ? https : http).request(options, (response) => {
                let contentBuffers = [];
                response.on('data', (chunk) => {
                    contentBuffers = contentBuffers.concat(chunk);
                });
                response.on('end', () => {
                    clearTimeout(connectTimeout);
                    clearTimeout(responseTimeout);
                    resolve({
                        status: response.statusCode || 0,
                        content: Buffer.concat(contentBuffers).toString(),
                        isTimedOut: false,
                    });
                });
            });
            const createTimeout = (timeout, content) => {
                return setTimeout(() => {
                    req.destroy();
                    resolve({
                        status: 0,
                        content,
                        isTimedOut: true,
                    });
                }, timeout);
            };
            connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');
            req.on('error', (error) => {
                clearTimeout(connectTimeout);
                clearTimeout(responseTimeout);
                resolve({ status: 0, content: error.message, isTimedOut: false });
            });
            req.once('response', () => {
                clearTimeout(connectTimeout);
                responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');
            });
            if (request.data !== undefined) {
                req.write(request.data);
            }
            req.end();
        });
    }
    return { send };
}

export { createHttpRequester, echoRequester };
