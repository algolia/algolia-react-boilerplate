/*! @algolia/predict-core 1.6.1 | MIT License | Â© Algolia, Inc. and contributors | https://github.com/algolia/predict */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@algolia/predict-core"] = {}));
})(this, (function (exports) { 'use strict';

  var zoneCounterRef = {
    current: 0
  };
  function createZone(_ref) {
    var id = _ref.id,
        name = _ref.name,
        _ref$active = _ref.active,
        active = _ref$active === void 0 ? true : _ref$active,
        _ref$happened = _ref.happened,
        happened = _ref$happened === void 0 ? false : _ref$happened;
    var zone = {
      id: id || "".concat(name, "-").concat(++zoneCounterRef.current),
      name: name,
      active: active,
      happened: happened
    };
    return zone;
  }

  /**
   * Throws an error if the condition is not met.
   *
   * The error is exhaustive in development, and becomes generic in production.
   *
   * This is used to make development a better experience to provide guidance as
   * to where the error comes from.
   */
  function invariant(condition, message) {
    if (condition) {
      return;
    }

    {
      throw new Error("[Predict] ".concat(typeof message === 'function' ? message() : message));
    }
  }

  /* eslint-disable no-console, no-empty */
  var warnCache = {
    current: {}
  };
  /**
   * Logs a warning if the condition is not met.
   * This is used to log issues in development environment only.
   */

  function warn(condition, message) {

    if (condition) {
      return;
    }

    var sanitizedMessage = message.trim();
    var hasAlreadyPrinted = warnCache.current[sanitizedMessage];

    if (!hasAlreadyPrinted) {
      warnCache.current[sanitizedMessage] = true;
      var warning = "[Predict] ".concat(sanitizedMessage);
      console.warn(warning);

      try {
        // Welcome to debugging Predict.
        //
        // This error was thrown as a convenience so that you can find the source
        // of the warning that appears in the console by enabling "Pause on exceptions"
        // in your debugger.
        throw new Error(warning);
      } catch (error) {}
    }
  }

  function computeCartAbandonment(funnelStage) {
    var addToCartPrediction = funnelStage.find( // The pipeline doesn't normalize the funnel stage values so we check it
    // against lowercase to support more cases.
    function (x) {
      return x.name.toLocaleLowerCase() === 'add_to_cart';
    }); // The `add_to_cart` funnel stage doesn't exist so that's not a cart abandonment
    // scenario.

    if (!addToCartPrediction) {
      return 0;
    }

    if (addToCartPrediction.probability >= // We don't use spread in the function call because Babel transformations blow
    // up the bundle size. Once we have more code that requires this syntax,
    // we can consider upgrading to:
    // Math.max(...funnelStage.map((stage) => stage.probability)) // not used for bundle optimization
    Math.max.apply(null, funnelStage.map(function (stage) {
      return stage.probability;
    }))) {
      // The `add_to_cart` prediction is the prediction that has the highest probability,
      // so this is a cart abandonment scenario.
      return 1;
    } else {
      return 0;
    }
  }

  /* eslint-disable no-console */

  /**
   * Logs a debug message.
   * This is used to log debugging messages in development environment only.
   */
  function logDebug(message) {
    var _console;

    var sanitizedMessage = message.trim();

    for (var _len = arguments.length, parts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      parts[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["[Predict] ".concat(sanitizedMessage)].concat(parts));
  }

  function isModelError(prediction) {
    return Boolean(prediction.error);
  }
  /**
   * Unwraps the prediction value, or falls back when it's unavailable.
   *
   * If the model is unavailable, it returns the fallback and triggers a warning.
   */


  function unwrapPrediction(predictions, model, fallback) {
    var prediction = predictions && predictions[model];

    if (!prediction) {
      return fallback;
    }

    if (isModelError(prediction)) {
      "development" !== 'production' ? warn(false, prediction.error) : void 0;
      return fallback;
    }

    return prediction.value;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function runAction(message, _ref) {
    var init = _ref.init,
        highlighter = _ref.highlighter,
        personifier = _ref.personifier;
    var type = message.type,
        data = message.data;
    var actions = {
      'request-init': function requestInit() {
        // Answer back to the Predict Tools that just opened.
        init();
      },
      'request-highlight-zone': function requestHighlightZone(_ref2) {
        var zoneId = _ref2.zoneId,
            params = _ref2.params;
        var predictZoneElement = document.querySelector("[data-predictzoneid=\"".concat(zoneId, "\"]"));

        if (predictZoneElement) {
          highlighter.select(predictZoneElement, _objectSpread$2({
            id: zoneId
          }, params));
        }
      },
      'request-unhighlight-zone': function requestUnhighlightZone(_ref3) {
        var zoneId = _ref3.zoneId;
        highlighter.unselect(zoneId);
      },
      'request-scroll-to-zone': function requestScrollToZone(_ref4) {
        var zoneId = _ref4.zoneId;
        var predictZoneElement = document.querySelector("[data-predictzoneid=\"".concat(zoneId, "\"]"));

        if (predictZoneElement) {
          var element = predictZoneElement;

          if (element.scrollIntoViewIfNeeded) {
            element.scrollIntoViewIfNeeded();
          } else {
            predictZoneElement.scrollIntoView();
          }
        }
      },
      'request-personification-start': function requestPersonificationStart(_ref5) {
        var userProfile = _ref5.userProfile;
        personifier.start({
          userProfile: userProfile
        });
      },
      'request-personification-end': function requestPersonificationEnd() {
        personifier.end();
      },
      disconnect: function disconnect() {
        highlighter.unselectAll();
      }
    };
    var action = actions[type];
    invariant(Boolean(action), "The Predict Tools event \"".concat(type, "\" is not implemented.")); // @ts-ignore At this point we know that we're manipulating the right data

    action(data);
  }

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function createElementHighlighter() {
    var highlights = {};

    function unselect(id) {
      var overlay = highlights[id];

      if (overlay) {
        document.body.removeChild(overlay);
        delete highlights[id];
      }
    }

    return {
      select: function select(referenceElement, props) {
        if (highlights[props.id]) {
          // Ignore if the element is already highlighted
          return;
        }

        var _referenceElement$get = referenceElement.getBoundingClientRect(),
            height = _referenceElement$get.height,
            width = _referenceElement$get.width,
            top = _referenceElement$get.top,
            left = _referenceElement$get.left;

        var overlay = document.createElement('div');
        overlay.setAttribute('data-predicthighlightid', props.id);

        var style = _objectSpread$1(_objectSpread$1({}, props.style), {}, {
          top: "".concat(top, "px"),
          left: "".concat(left, "px"),
          height: "".concat(height, "px"),
          width: "".concat(width, "px")
        });

        Object.keys(style).forEach(function (attribute) {
          overlay.style[attribute] = style[attribute];
        });
        highlights[props.id] = overlay;
        document.body.appendChild(overlay);
      },
      unselect: unselect,
      unselectAll: function unselectAll() {
        Object.keys(highlights).forEach(function (id) {
          return unselect(id);
        });
      }
    };
  }

  var STORAGE_KEY_PREFIX = 'predict';
  var STORAGE_TEST_KEY = "".concat(STORAGE_KEY_PREFIX, "/test-key");

  function isStorageSupported(storage) {
    try {
      storage.setItem(STORAGE_TEST_KEY, '');
      storage.removeItem(STORAGE_TEST_KEY);
      return true;
    } catch (error) {
      return false;
    }
  }

  function createInMemoryStorage() {
    return {
      get: function get() {
        return null;
      },
      set: function set() {},
      remove: function remove() {}
    };
  }

  function createStorage(_ref) {
    var key = _ref.key,
        storage = _ref.storage;

    if (!isStorageSupported(storage)) {
      return createInMemoryStorage();
    }

    var storageKey = "".concat(STORAGE_KEY_PREFIX, "/").concat(key);
    return {
      get: function get() {
        var item = storage.getItem(storageKey);
        return item ? JSON.parse(item) : null;
      },
      set: function set(value) {
        storage.setItem(storageKey, JSON.stringify(value));
      },
      remove: function remove() {
        storage.removeItem(storageKey);
      }
    };
  }

  function createSessionStorage(_ref2) {
    var key = _ref2.key;
    return createStorage({
      key: key,
      storage: sessionStorage
    });
  }

  function createPersonifier(_ref) {
    var onPersonificationStart = _ref.onPersonificationStart,
        onPersonificationEnd = _ref.onPersonificationEnd;
    var personificationSessionStorage = createSessionStorage({
      key: 'tools/userProfile'
    });
    var personifiedUserProfile = personificationSessionStorage.get();

    var _isPersonifying = Boolean(personifiedUserProfile);

    var api = {
      isPersonifying: function isPersonifying() {
        return _isPersonifying;
      },
      start: function start(_ref2) {
        var userProfile = _ref2.userProfile;
        logDebug("Personification started with user \"".concat(userProfile.user, "\"."));
        _isPersonifying = true;
        onPersonificationStart({
          userProfile: userProfile
        });
        personificationSessionStorage.set(userProfile);
      },
      end: function end() {
        logDebug('Personification ended.');
        _isPersonifying = false;
        onPersonificationEnd();
        personificationSessionStorage.remove();
      },
      loadUserProfileFromStorage: function loadUserProfileFromStorage() {
        if (personifiedUserProfile) {
          // To avoid hydration mismatches errors in SSR frameworks like React,
          // we need to start the personification after the first browser render.
          // Unfortunately this means that there's a first render with the actual
          // user profile, and then an update in the next microtask to override it
          // with the personified user profile, resulting in a UI flash.
          // Ideally, we should find a way to override the user profile directly
          // without the hydration warning.
          // See https://beta.reactjs.org/apis/react-dom/client/hydrateRoot#handling-different-client-and-server-content
          queueMicrotask(function () {
            api.start({
              userProfile: personifiedUserProfile
            });
          });
        }
      }
    };
    return api;
  }

  var PREDICT_TO_EXTENSION = 'predict-to-extension';
  var EXTENSION_TO_PREDICT = 'extension-to-predict';

  var _excluded = ["eventType"];

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  var sendMessage = function sendMessage(message) {
    window.postMessage(_objectSpread({
      source: PREDICT_TO_EXTENSION
    }, message), '*');
  };

  function initPredictTools(_ref) {
    var version = _ref.version,
        getContext = _ref.getContext,
        subscribe = _ref.subscribe,
        startPersonification = _ref.startPersonification,
        endPersonification = _ref.endPersonification;
    var highlighter = createElementHighlighter();
    var personifier = createPersonifier({
      onPersonificationStart: startPersonification,
      onPersonificationEnd: endPersonification
    });
    personifier.loadUserProfileFromStorage();
    /**
     * Notifies the Predict Tools from the Predict context.
     */

    function init() {
      sendMessage({
        type: 'init',
        data: {
          version: version,
          context: getContext(),
          isPersonifying: personifier.isPersonifying()
        }
      });
    } // We initialize the Predict Tools right away if the browser's DevTools are open.


    init(); // And we send any state change updates to the Predict Tools.

    subscribe(function (_ref2) {
      _ref2.eventType;
          var context = _objectWithoutProperties(_ref2, _excluded);

      sendMessage({
        type: 'state-change',
        data: {
          version: version,
          context: context,
          isPersonifying: personifier.isPersonifying()
        }
      });
    }); // Then, we listen to messages coming from the Predict Tools.

    window.addEventListener('message', function (event) {
      if (event.data.source === EXTENSION_TO_PREDICT) {
        runAction(event.data, {
          init: init,
          highlighter: highlighter,
          personifier: personifier
        });
      }
    });
  }

  var version = '1.6.1';

  function predict(params) {
    var PREDICT_TOOLS_ENABLED = typeof window !== 'undefined';
    var subscribers = [];
    var userProfile = params.userProfile;
    var zones = [];
    var isPersonificationEnabled = false;
    /**
     * Maintains a queue of updates that need to be applied once the personification ends.
     *
     * We ignore `update()` calls when personifying to give precedence to the personified user profile.
     * So we need to apply the updates at the end of the personification to ensure
     * the latest changes are reflected.
     */

    var pendingUpdates = [];

    var applyUpdate = function applyUpdate(nextParams) {
      if (nextParams.userProfile) {
        userProfile = nextParams.userProfile;
      }
    };

    var update = function update(nextParams) {
      if (PREDICT_TOOLS_ENABLED) {
        if (isPersonificationEnabled) {
          logDebug('Skipped update because the Predict Tools extension is personifying the user.', nextParams);
          pendingUpdates.push(nextParams);
          return;
        }
      }

      applyUpdate(nextParams);
      notify('UPDATED');
    };

    var getUserProfile = function getUserProfile() {
      return userProfile;
    };

    var getSegments = function getSegments() {
      return Object.entries(userProfile.segments || {}).reduce(function (acc, segment) {
        // We don't use array destructuring because Babel transformations blow
        // up the bundle size. Once we have more code that requires this syntax,
        // we can consider upgrading to:
        // const [type, names] = segment; // not used for bundle optimization
        var type = segment[0];
        var names = segment[1];
        var segmentsInType = names.map(function (name) {
          return {
            name: name,
            type: type
          };
        });
        segmentsInType.forEach(function (segmentInType) {
          acc.push(segmentInType);
        });
        return acc;
      }, []);
    };

    var getProperties = function getProperties() {
      return Object.entries(userProfile.properties || {}).reduce(function (acc, group) {
        // const [type, properties] = group; // not used for bundle optimization
        var type = group[0];
        var properties = group[1];
        var propertiesInType = Object.entries(properties || {}).map(function (property) {
          // const [key, value] = property; // not used for bundle optimization
          var key = property[0];
          var value = property[1];
          return {
            name: key,
            value: value,
            type: type
          };
        });
        propertiesInType.forEach(function (propertyInType) {
          acc.push(propertyInType);
        });
        return acc;
      }, []);
    };

    var getAffinities = function getAffinities() {
      return unwrapPrediction(userProfile.predictions, 'affinities', []);
    };

    var getFunnelStage = function getFunnelStage() {
      return unwrapPrediction(userProfile.predictions, 'funnel_stage', []);
    };

    var getOrderValue = function getOrderValue() {
      return unwrapPrediction(userProfile.predictions, 'order_value', undefined);
    };

    var getCartAbandonment = function getCartAbandonment() {
      return computeCartAbandonment(getFunnelStage());
    };

    var getZones = function getZones() {
      return zones;
    };

    var addZone = function addZone(newZone) {
      invariant(!zones.some(function (zone) {
        return zone.id === newZone.id;
      }), "Cannot add zone with ID \"".concat(newZone.id, "\" because it already exists."));
      zones.push(newZone);
      notify('ZONE_ADDED');
      return newZone;
    };

    var removeZone = function removeZone(zone) {
      var zoneIndex = zones.findIndex(function (x) {
        return x.id === zone.id;
      });
      invariant(zoneIndex !== -1, "Cannot remove zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
      zones.splice(zoneIndex, 1);
      notify('ZONE_REMOVED');
    };

    var updateZone = function updateZone(zone) {
      var _zone$name, _zone$active, _zone$happened;

      var zoneIndex = zones.findIndex(function (x) {
        return x.id === zone.id;
      });
      invariant(zoneIndex !== -1, "Cannot update zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
      var prevZone = zones[zoneIndex];
      var updatedZone = {
        id: zone.id,
        name: (_zone$name = zone.name) !== null && _zone$name !== void 0 ? _zone$name : prevZone.name,
        active: (_zone$active = zone.active) !== null && _zone$active !== void 0 ? _zone$active : prevZone.active,
        happened: (_zone$happened = zone.happened) !== null && _zone$happened !== void 0 ? _zone$happened : prevZone.happened
      };
      zones[zoneIndex] = updatedZone;
      notify('ZONE_UPDATED');
      return updatedZone;
    };

    var subscribe = function subscribe(subscriber) {
      subscribers.push(subscriber);
      return function () {
        subscribers = subscribers.filter(function (x) {
          return x !== subscriber;
        });
      };
    };

    function notify(eventType) {
      subscribers.forEach(function (subscriber) {
        subscriber({
          eventType: eventType,
          affinities: getAffinities(),
          cartAbandonment: getCartAbandonment(),
          funnelStage: getFunnelStage(),
          orderValue: getOrderValue(),
          segments: getSegments(),
          properties: getProperties(),
          userProfile: getUserProfile(),
          zones: getZones()
        });
      });
    } // Predict Tools are enabled in development mode, or when the `PREDICT_TOOLS`
    // environment variable is set. This is useful to use the web extension in
    // staging environments.


    if (PREDICT_TOOLS_ENABLED) {
      initPredictTools({
        version: version,
        subscribe: subscribe,
        getContext: function getContext() {
          return {
            affinities: getAffinities(),
            cartAbandonment: getCartAbandonment(),
            funnelStage: getFunnelStage(),
            orderValue: getOrderValue(),
            segments: getSegments(),
            properties: getProperties(),
            userProfile: getUserProfile(),
            zones: getZones()
          };
        },
        startPersonification: function startPersonification(_ref) {
          var userProfileToPersonify = _ref.userProfile;
          pendingUpdates.push({
            userProfile: userProfile
          });
          update({
            userProfile: userProfileToPersonify
          });
          isPersonificationEnabled = true;
        },
        endPersonification: function endPersonification() {
          isPersonificationEnabled = false;

          while (pendingUpdates.length > 0) {
            var updateParams = pendingUpdates.shift();
            applyUpdate(updateParams);
          } // We trigger an update to notify subscribers.


          update({});
        }
      });
    }

    var api = {
      getAffinities: getAffinities,
      getFunnelStage: getFunnelStage,
      getOrderValue: getOrderValue,
      getCartAbandonment: getCartAbandonment,
      getSegments: getSegments,
      getProperties: getProperties,
      getUserProfile: getUserProfile,
      getZones: getZones,
      update: update,
      addZone: addZone,
      removeZone: removeZone,
      updateZone: updateZone,
      subscribe: subscribe
    };
    return api;
  }

  exports.createZone = createZone;
  exports.invariant = invariant;
  exports.predict = predict;
  exports.version = version;
  exports.warn = warn;
  exports.warnCache = warnCache;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
