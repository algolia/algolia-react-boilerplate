{"version":3,"file":"index.production.js","sources":["../../src/createZone.ts","../../src/lib/invariant.ts","../../src/lib/warn.ts","../../src/lib/unwrapPrediction.ts","../../src/predict.ts","../../src/lib/computeCartAbandonment.ts","../../src/version.ts"],"sourcesContent":["import { Zone } from './predict';\n\nexport const zoneCounterRef = { current: 0 };\n\nexport type ZoneOptions = {\n  id?: Zone['id'];\n  name: Zone['name'];\n  active?: Zone['active'];\n  happened?: Zone['happened'];\n};\n\nexport function createZone({\n  id,\n  name,\n  active = true,\n  happened = false,\n}: ZoneOptions): Zone {\n  const zone: Zone = {\n    id: id || `${name}-${++zoneCounterRef.current}`,\n    name,\n    active,\n    happened,\n  };\n\n  return zone;\n}\n","/**\n * Throws an error if the condition is not met.\n *\n * The error is exhaustive in development, and becomes generic in production.\n *\n * This is used to make development a better experience to provide guidance as\n * to where the error comes from.\n */\nexport function invariant(\n  condition: boolean,\n  message: string | (() => string)\n): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  /* istanbul ignore next */\n  if (!__DEV__) {\n    throw new Error('Invariant failed');\n  }\n\n  if (__DEV__) {\n    throw new Error(\n      `[Predict] ${typeof message === 'function' ? message() : message}`\n    );\n  }\n}\n","/* eslint-disable no-console, no-empty */\n\nexport const warnCache = {\n  current: {},\n};\n\n/**\n * Logs a warning if the condition is not met.\n * This is used to log issues in development environment only.\n */\nexport function warn(condition: boolean, message: string) {\n  /* istanbul ignore next */\n  if (!__DEV__) {\n    return;\n  }\n\n  if (condition) {\n    return;\n  }\n\n  const sanitizedMessage = message.trim();\n  const hasAlreadyPrinted = warnCache.current[sanitizedMessage];\n\n  if (!hasAlreadyPrinted) {\n    warnCache.current[sanitizedMessage] = true;\n    const warning = `[Predict] ${sanitizedMessage}`;\n\n    console.warn(warning);\n\n    try {\n      // Welcome to debugging Predict.\n      //\n      // This error was thrown as a convenience so that you can find the source\n      // of the warning that appears in the console by enabling \"Pause on exceptions\"\n      // in your debugger.\n      throw new Error(warning);\n    } catch (error) {}\n  }\n}\n","import { type ModelError, type Predictions } from '@algolia/predict';\n\nimport { warn } from './warn';\n\ntype ValueOf<T> = T[keyof T];\n\nfunction isModelError(\n  prediction: Required<ValueOf<Predictions>>\n): prediction is ModelError {\n  return Boolean((prediction as ModelError).error);\n}\n\n/**\n * Unwraps the prediction value, or falls back when it's unavailable.\n *\n * If the model is unavailable, it returns the fallback and triggers a warning.\n */\nexport function unwrapPrediction<TType>(\n  predictions: Predictions | undefined,\n  model: keyof Predictions,\n  fallback: TType\n): TType {\n  const prediction = predictions && predictions[model];\n\n  if (!prediction) {\n    return fallback;\n  }\n\n  if (isModelError(prediction)) {\n    warn(false, prediction.error);\n    return fallback;\n  }\n\n  return prediction.value as unknown as TType;\n}\n","import { computeCartAbandonment } from './lib/computeCartAbandonment';\nimport { invariant } from './lib/invariant';\nimport { logDebug } from './lib/logDebug';\nimport { unwrapPrediction } from './lib/unwrapPrediction';\nimport { initPredictTools } from './tools';\nimport {\n  type Affinity,\n  type FunnelStage,\n  type OrderValue,\n  type Property,\n  type Segment,\n  type UserProfile,\n} from './types';\nimport { version } from './version';\n\nexport type PredictApi = {\n  affinities: Affinity[];\n  cartAbandonment: number;\n  funnelStage: FunnelStage[];\n  orderValue: OrderValue | undefined;\n  segments: Segment[];\n  properties: Property[];\n  userProfile: UserProfile;\n  zones: Zone[];\n};\n\nexport type Zone = {\n  id: string;\n  name: string;\n  active: boolean;\n  happened: boolean;\n};\n\ntype EventType = 'UPDATED' | 'ZONE_ADDED' | 'ZONE_REMOVED' | 'ZONE_UPDATED';\ntype Subscriber = (params: PredictApi & { eventType: EventType }) => void;\n\nexport type PredictCoreApi = {\n  getAffinities: () => Affinity[];\n  getFunnelStage: () => FunnelStage[];\n  getOrderValue: () => OrderValue | undefined;\n  getCartAbandonment: () => number;\n  getSegments: () => Segment[];\n  getProperties: () => Property[];\n  getUserProfile: () => UserProfile;\n  getZones: () => Zone[];\n  update: (nextParams: Partial<PredictOptions>) => void;\n  addZone: (zone: Zone) => Zone;\n  removeZone: (zone: Zone) => void;\n  updateZone: (zone: Pick<Zone, 'id'> & Partial<Zone>) => Zone;\n  subscribe: (subscriber: Subscriber) => () => void;\n};\n\nexport type PredictOptions = {\n  userProfile: UserProfile;\n};\n\nexport function predict(params: PredictOptions): PredictCoreApi {\n  const PREDICT_TOOLS_ENABLED =\n    (__DEV__ || __PREDICT_TOOLS__) && typeof window !== 'undefined';\n\n  let subscribers: Subscriber[] = [];\n  let userProfile = params.userProfile;\n  const zones: Zone[] = [];\n  let isPersonificationEnabled = false;\n  /**\n   * Maintains a queue of updates that need to be applied once the personification ends.\n   *\n   * We ignore `update()` calls when personifying to give precedence to the personified user profile.\n   * So we need to apply the updates at the end of the personification to ensure\n   * the latest changes are reflected.\n   */\n  const pendingUpdates: Array<Parameters<PredictCoreApi['update']>[0]> = [];\n\n  const applyUpdate = (nextParams: Parameters<PredictCoreApi['update']>[0]) => {\n    if (nextParams.userProfile) {\n      userProfile = nextParams.userProfile;\n    }\n  };\n\n  const update: PredictCoreApi['update'] = (nextParams) => {\n    if (PREDICT_TOOLS_ENABLED) {\n      if (isPersonificationEnabled) {\n        logDebug(\n          'Skipped update because the Predict Tools extension is personifying the user.',\n          nextParams\n        );\n\n        pendingUpdates.push(nextParams);\n\n        return;\n      }\n    }\n\n    applyUpdate(nextParams);\n\n    notify('UPDATED');\n  };\n\n  const getUserProfile: PredictCoreApi['getUserProfile'] = () => userProfile;\n\n  const getSegments: PredictCoreApi['getSegments'] = () => {\n    return Object.entries(userProfile.segments || {}).reduce<Segment[]>(\n      (acc, segment) => {\n        // We don't use array destructuring because Babel transformations blow\n        // up the bundle size. Once we have more code that requires this syntax,\n        // we can consider upgrading to:\n        // const [type, names] = segment; // not used for bundle optimization\n        const type = segment[0];\n        const names = segment[1];\n        const segmentsInType = names.map<Segment>((name) => ({\n          name,\n          type: type as Segment['type'],\n        }));\n\n        segmentsInType.forEach((segmentInType) => {\n          acc.push(segmentInType);\n        });\n\n        return acc;\n      },\n      []\n    );\n  };\n\n  const getProperties: PredictCoreApi['getProperties'] = () => {\n    return Object.entries(userProfile.properties || {}).reduce<Property[]>(\n      (acc, group) => {\n        // const [type, properties] = group; // not used for bundle optimization\n        const type = group[0];\n        const properties = group[1];\n\n        const propertiesInType = Object.entries(properties || {}).map<Property>(\n          (property) => {\n            // const [key, value] = property; // not used for bundle optimization\n            const key = property[0];\n            const value = property[1];\n\n            return {\n              name: key,\n              value,\n              type: type as Property['type'],\n            };\n          }\n        );\n\n        propertiesInType.forEach((propertyInType) => {\n          acc.push(propertyInType);\n        });\n\n        return acc;\n      },\n      []\n    );\n  };\n\n  const getAffinities: PredictCoreApi['getAffinities'] = () => {\n    return unwrapPrediction<Affinity[]>(\n      userProfile.predictions,\n      'affinities',\n      []\n    );\n  };\n\n  const getFunnelStage: PredictCoreApi['getFunnelStage'] = () => {\n    return unwrapPrediction<FunnelStage[]>(\n      userProfile.predictions,\n      'funnel_stage',\n      []\n    );\n  };\n\n  const getOrderValue: PredictCoreApi['getOrderValue'] = () => {\n    return unwrapPrediction<OrderValue | undefined>(\n      userProfile.predictions,\n      'order_value',\n      undefined\n    );\n  };\n\n  const getCartAbandonment: PredictCoreApi['getCartAbandonment'] = () =>\n    computeCartAbandonment(getFunnelStage());\n\n  const getZones: PredictCoreApi['getZones'] = () => zones;\n\n  const addZone: PredictCoreApi['addZone'] = (newZone) => {\n    invariant(\n      !zones.some((zone) => zone.id === newZone.id),\n      `Cannot add zone with ID \"${newZone.id}\" because it already exists.`\n    );\n\n    zones.push(newZone);\n    notify('ZONE_ADDED');\n\n    return newZone;\n  };\n\n  const removeZone: PredictCoreApi['removeZone'] = (zone) => {\n    const zoneIndex = zones.findIndex((x) => x.id === zone.id);\n\n    invariant(\n      zoneIndex !== -1,\n      `Cannot remove zone with ID \"${zone.id}\" because it doesn't exist.`\n    );\n\n    zones.splice(zoneIndex, 1);\n    notify('ZONE_REMOVED');\n  };\n\n  const updateZone: PredictCoreApi['updateZone'] = (zone) => {\n    const zoneIndex = zones.findIndex((x) => x.id === zone.id);\n\n    invariant(\n      zoneIndex !== -1,\n      `Cannot update zone with ID \"${zone.id}\" because it doesn't exist.`\n    );\n\n    const prevZone = zones[zoneIndex];\n    const updatedZone = {\n      id: zone.id,\n      name: zone.name ?? prevZone.name,\n      active: zone.active ?? prevZone.active,\n      happened: zone.happened ?? prevZone.happened,\n    };\n\n    zones[zoneIndex] = updatedZone;\n\n    notify('ZONE_UPDATED');\n\n    return updatedZone;\n  };\n\n  const subscribe: PredictCoreApi['subscribe'] = (subscriber) => {\n    subscribers.push(subscriber);\n\n    return () => {\n      subscribers = subscribers.filter((x) => x !== subscriber);\n    };\n  };\n\n  function notify(eventType: EventType) {\n    subscribers.forEach((subscriber) => {\n      subscriber({\n        eventType,\n        affinities: getAffinities(),\n        cartAbandonment: getCartAbandonment(),\n        funnelStage: getFunnelStage(),\n        orderValue: getOrderValue(),\n        segments: getSegments(),\n        properties: getProperties(),\n        userProfile: getUserProfile(),\n        zones: getZones(),\n      });\n    });\n  }\n\n  // Predict Tools are enabled in development mode, or when the `PREDICT_TOOLS`\n  // environment variable is set. This is useful to use the web extension in\n  // staging environments.\n  if (PREDICT_TOOLS_ENABLED) {\n    initPredictTools({\n      version,\n      subscribe,\n      getContext: () => ({\n        affinities: getAffinities(),\n        cartAbandonment: getCartAbandonment(),\n        funnelStage: getFunnelStage(),\n        orderValue: getOrderValue(),\n        segments: getSegments(),\n        properties: getProperties(),\n        userProfile: getUserProfile(),\n        zones: getZones(),\n      }),\n      startPersonification: ({ userProfile: userProfileToPersonify }) => {\n        pendingUpdates.push({ userProfile });\n        update({ userProfile: userProfileToPersonify });\n        isPersonificationEnabled = true;\n      },\n      endPersonification: () => {\n        isPersonificationEnabled = false;\n\n        while (pendingUpdates.length > 0) {\n          const updateParams = pendingUpdates.shift()!;\n          applyUpdate(updateParams);\n        }\n\n        // We trigger an update to notify subscribers.\n        update({});\n      },\n    });\n  }\n\n  const api = {\n    getAffinities,\n    getFunnelStage,\n    getOrderValue,\n    getCartAbandonment,\n    getSegments,\n    getProperties,\n    getUserProfile,\n    getZones,\n    update,\n    addZone,\n    removeZone,\n    updateZone,\n    subscribe,\n  };\n\n  return api;\n}\n","import { type FunnelStage } from '../types';\n\nexport function computeCartAbandonment(funnelStage: FunnelStage[]) {\n  const addToCartPrediction = funnelStage.find(\n    // The pipeline doesn't normalize the funnel stage values so we check it\n    // against lowercase to support more cases.\n    (x) => x.name.toLocaleLowerCase() === 'add_to_cart'\n  );\n\n  // The `add_to_cart` funnel stage doesn't exist so that's not a cart abandonment\n  // scenario.\n  if (!addToCartPrediction) {\n    return 0;\n  }\n\n  if (\n    addToCartPrediction.probability >=\n    // We don't use spread in the function call because Babel transformations blow\n    // up the bundle size. Once we have more code that requires this syntax,\n    // we can consider upgrading to:\n    // Math.max(...funnelStage.map((stage) => stage.probability)) // not used for bundle optimization\n    Math.max.apply(\n      null,\n      funnelStage.map((stage) => stage.probability)\n    )\n  ) {\n    // The `add_to_cart` prediction is the prediction that has the highest probability,\n    // so this is a cart abandonment scenario.\n    return 1;\n  } else {\n    return 0;\n  }\n}\n","export const version = '1.6.1';\n"],"names":["zoneCounterRef","current","invariant","condition","message","Error","warn","unwrapPrediction","predictions","model","fallback","prediction","Boolean","error","isModelError","value","_ref","id","name","_ref$active","active","_ref$happened","happened","params","subscribers","userProfile","zones","getUserProfile","getSegments","Object","entries","segments","reduce","acc","segment","type","map","forEach","segmentInType","push","getProperties","properties","group","property","propertyInType","getAffinities","getFunnelStage","getOrderValue","undefined","getCartAbandonment","funnelStage","addToCartPrediction","find","x","toLocaleLowerCase","probability","Math","max","apply","stage","getZones","notify","eventType","subscriber","affinities","cartAbandonment","orderValue","update","nextParams","applyUpdate","addZone","newZone","some","zone","concat","removeZone","zoneIndex","findIndex","splice","updateZone","_zone$name","_zone$active","_zone$happened","prevZone","updatedZone","subscribe","filter"],"mappings":"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"}