import { computeCartAbandonment } from './lib/computeCartAbandonment';
import { invariant } from './lib/invariant';
import { logDebug } from './lib/logDebug';
import { unwrapPrediction } from './lib/unwrapPrediction';
import { initPredictTools } from './tools';
import { version } from './version';
export function predict(params) {
  var PREDICT_TOOLS_ENABLED = (process.env.NODE_ENV !== 'production' || process.env.PREDICT_TOOLS === 'true') && typeof window !== 'undefined';
  var subscribers = [];
  var userProfile = params.userProfile;
  var zones = [];
  var isPersonificationEnabled = false;
  /**
   * Maintains a queue of updates that need to be applied once the personification ends.
   *
   * We ignore `update()` calls when personifying to give precedence to the personified user profile.
   * So we need to apply the updates at the end of the personification to ensure
   * the latest changes are reflected.
   */

  var pendingUpdates = [];

  var applyUpdate = function applyUpdate(nextParams) {
    if (nextParams.userProfile) {
      userProfile = nextParams.userProfile;
    }
  };

  var update = function update(nextParams) {
    if (PREDICT_TOOLS_ENABLED) {
      if (isPersonificationEnabled) {
        logDebug('Skipped update because the Predict Tools extension is personifying the user.', nextParams);
        pendingUpdates.push(nextParams);
        return;
      }
    }

    applyUpdate(nextParams);
    notify('UPDATED');
  };

  var getUserProfile = function getUserProfile() {
    return userProfile;
  };

  var getSegments = function getSegments() {
    return Object.entries(userProfile.segments || {}).reduce(function (acc, segment) {
      // We don't use array destructuring because Babel transformations blow
      // up the bundle size. Once we have more code that requires this syntax,
      // we can consider upgrading to:
      // const [type, names] = segment; // not used for bundle optimization
      var type = segment[0];
      var names = segment[1];
      var segmentsInType = names.map(function (name) {
        return {
          name: name,
          type: type
        };
      });
      segmentsInType.forEach(function (segmentInType) {
        acc.push(segmentInType);
      });
      return acc;
    }, []);
  };

  var getProperties = function getProperties() {
    return Object.entries(userProfile.properties || {}).reduce(function (acc, group) {
      // const [type, properties] = group; // not used for bundle optimization
      var type = group[0];
      var properties = group[1];
      var propertiesInType = Object.entries(properties || {}).map(function (property) {
        // const [key, value] = property; // not used for bundle optimization
        var key = property[0];
        var value = property[1];
        return {
          name: key,
          value: value,
          type: type
        };
      });
      propertiesInType.forEach(function (propertyInType) {
        acc.push(propertyInType);
      });
      return acc;
    }, []);
  };

  var getAffinities = function getAffinities() {
    return unwrapPrediction(userProfile.predictions, 'affinities', []);
  };

  var getFunnelStage = function getFunnelStage() {
    return unwrapPrediction(userProfile.predictions, 'funnel_stage', []);
  };

  var getOrderValue = function getOrderValue() {
    return unwrapPrediction(userProfile.predictions, 'order_value', undefined);
  };

  var getCartAbandonment = function getCartAbandonment() {
    return computeCartAbandonment(getFunnelStage());
  };

  var getZones = function getZones() {
    return zones;
  };

  var addZone = function addZone(newZone) {
    invariant(!zones.some(function (zone) {
      return zone.id === newZone.id;
    }), "Cannot add zone with ID \"".concat(newZone.id, "\" because it already exists."));
    zones.push(newZone);
    notify('ZONE_ADDED');
    return newZone;
  };

  var removeZone = function removeZone(zone) {
    var zoneIndex = zones.findIndex(function (x) {
      return x.id === zone.id;
    });
    invariant(zoneIndex !== -1, "Cannot remove zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
    zones.splice(zoneIndex, 1);
    notify('ZONE_REMOVED');
  };

  var updateZone = function updateZone(zone) {
    var _zone$name, _zone$active, _zone$happened;

    var zoneIndex = zones.findIndex(function (x) {
      return x.id === zone.id;
    });
    invariant(zoneIndex !== -1, "Cannot update zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
    var prevZone = zones[zoneIndex];
    var updatedZone = {
      id: zone.id,
      name: (_zone$name = zone.name) !== null && _zone$name !== void 0 ? _zone$name : prevZone.name,
      active: (_zone$active = zone.active) !== null && _zone$active !== void 0 ? _zone$active : prevZone.active,
      happened: (_zone$happened = zone.happened) !== null && _zone$happened !== void 0 ? _zone$happened : prevZone.happened
    };
    zones[zoneIndex] = updatedZone;
    notify('ZONE_UPDATED');
    return updatedZone;
  };

  var subscribe = function subscribe(subscriber) {
    subscribers.push(subscriber);
    return function () {
      subscribers = subscribers.filter(function (x) {
        return x !== subscriber;
      });
    };
  };

  function notify(eventType) {
    subscribers.forEach(function (subscriber) {
      subscriber({
        eventType: eventType,
        affinities: getAffinities(),
        cartAbandonment: getCartAbandonment(),
        funnelStage: getFunnelStage(),
        orderValue: getOrderValue(),
        segments: getSegments(),
        properties: getProperties(),
        userProfile: getUserProfile(),
        zones: getZones()
      });
    });
  } // Predict Tools are enabled in development mode, or when the `PREDICT_TOOLS`
  // environment variable is set. This is useful to use the web extension in
  // staging environments.


  if (PREDICT_TOOLS_ENABLED) {
    initPredictTools({
      version: version,
      subscribe: subscribe,
      getContext: function getContext() {
        return {
          affinities: getAffinities(),
          cartAbandonment: getCartAbandonment(),
          funnelStage: getFunnelStage(),
          orderValue: getOrderValue(),
          segments: getSegments(),
          properties: getProperties(),
          userProfile: getUserProfile(),
          zones: getZones()
        };
      },
      startPersonification: function startPersonification(_ref) {
        var userProfileToPersonify = _ref.userProfile;
        pendingUpdates.push({
          userProfile: userProfile
        });
        update({
          userProfile: userProfileToPersonify
        });
        isPersonificationEnabled = true;
      },
      endPersonification: function endPersonification() {
        isPersonificationEnabled = false;

        while (pendingUpdates.length > 0) {
          var updateParams = pendingUpdates.shift();
          applyUpdate(updateParams);
        } // We trigger an update to notify subscribers.


        update({});
      }
    });
  }

  var api = {
    getAffinities: getAffinities,
    getFunnelStage: getFunnelStage,
    getOrderValue: getOrderValue,
    getCartAbandonment: getCartAbandonment,
    getSegments: getSegments,
    getProperties: getProperties,
    getUserProfile: getUserProfile,
    getZones: getZones,
    update: update,
    addZone: addZone,
    removeZone: removeZone,
    updateZone: updateZone,
    subscribe: subscribe
  };
  return api;
}