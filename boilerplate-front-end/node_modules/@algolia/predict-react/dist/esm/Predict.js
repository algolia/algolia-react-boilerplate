import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["eventType"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import { predict, warn } from '@algolia/predict-core';
import { dequal } from 'dequal/lite';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import { PredictContext } from './lib/PredictContext';
export function Predict(_ref) {
  var userProfile = _ref.userProfile,
      _ref$suppressExperime = _ref.suppressExperimentalWarning,
      suppressExperimentalWarning = _ref$suppressExperime === void 0 ? false : _ref$suppressExperime,
      children = _ref.children;
  var predictRef = useRef(null);

  if (predictRef.current === null) {
    predictRef.current = predict({
      userProfile: userProfile
    });
  }

  var _useState = useState(function () {
    return {
      userProfile: predictRef.current.getUserProfile(),
      affinities: predictRef.current.getAffinities(),
      funnelStage: predictRef.current.getFunnelStage(),
      orderValue: predictRef.current.getOrderValue(),
      cartAbandonment: predictRef.current.getCartAbandonment(),
      segments: predictRef.current.getSegments(),
      properties: predictRef.current.getProperties(),
      zones: predictRef.current.getZones(),
      addZone: predictRef.current.addZone,
      removeZone: predictRef.current.removeZone,
      updateZone: predictRef.current.updateZone,
      subscribe: predictRef.current.subscribe
    };
  }),
      _useState2 = _slicedToArray(_useState, 2),
      predictApi = _useState2[0],
      setPredictApi = _useState2[1];

  var _useState3 = useState(function () {
    return predictRef.current.getUserProfile();
  }),
      _useState4 = _slicedToArray(_useState3, 2),
      prevUserProfile = _useState4[0],
      setPrevUserProfile = _useState4[1];

  if (!dequal(userProfile, prevUserProfile)) {
    predictRef.current.update({
      userProfile: userProfile
    });
    setPrevUserProfile(userProfile);
  }

  var store = useSyncExternalStore(useCallback(function () {
    return predictRef.current.subscribe(function (_ref2) {
      var eventType = _ref2.eventType,
          state = _objectWithoutProperties(_ref2, _excluded);

      // We manage zone updates directly with the React state, so we don't
      // need to listen to this event.
      if (eventType !== 'ZONE_UPDATED') {
        setPredictApi(function (prev) {
          return _objectSpread(_objectSpread({}, prev), state);
        });
      }
    });
  }, []), function () {
    return predictApi;
  }, function () {
    return predictApi;
  });
  useEffect(function () {
    process.env.NODE_ENV !== 'production' ? warn(suppressExperimentalWarning, 'This version is experimental and not production-ready.\n\n' + 'Please report any bugs at https://github.com/algolia/predict/issues/new\n\n' + '(To disable this warning, pass `suppressExperimentalWarning` to <Predict>.)') : void 0;
  }, [suppressExperimentalWarning]);
  return /*#__PURE__*/React.createElement(PredictContext.Provider, {
    value: store
  }, children);
}