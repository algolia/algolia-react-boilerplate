/*! @algolia/predict-react 1.6.1 | MIT License | Â© Algolia, Inc. and contributors | https://github.com/algolia/predict */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@algolia/predict-react"] = {}, global.React));
})(this, (function (exports, React) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  var zoneCounterRef = {
    current: 0
  };
  function createZone(_ref) {
    var id = _ref.id,
        name = _ref.name,
        _ref$active = _ref.active,
        active = _ref$active === void 0 ? true : _ref$active,
        _ref$happened = _ref.happened,
        happened = _ref$happened === void 0 ? false : _ref$happened;
    var zone = {
      id: id || "".concat(name, "-").concat(++zoneCounterRef.current),
      name: name,
      active: active,
      happened: happened
    };
    return zone;
  }

  /**
   * Throws an error if the condition is not met.
   *
   * The error is exhaustive in development, and becomes generic in production.
   *
   * This is used to make development a better experience to provide guidance as
   * to where the error comes from.
   */
  function invariant(condition, message) {
    if (condition) {
      return;
    }

    {
      throw new Error("[Predict] ".concat(typeof message === 'function' ? message() : message));
    }
  }

  /* eslint-disable no-console, no-empty */
  var warnCache = {
    current: {}
  };
  /**
   * Logs a warning if the condition is not met.
   * This is used to log issues in development environment only.
   */

  function warn(condition, message) {

    if (condition) {
      return;
    }

    var sanitizedMessage = message.trim();
    var hasAlreadyPrinted = warnCache.current[sanitizedMessage];

    if (!hasAlreadyPrinted) {
      warnCache.current[sanitizedMessage] = true;
      var warning = "[Predict] ".concat(sanitizedMessage);
      console.warn(warning);

      try {
        // Welcome to debugging Predict.
        //
        // This error was thrown as a convenience so that you can find the source
        // of the warning that appears in the console by enabling "Pause on exceptions"
        // in your debugger.
        throw new Error(warning);
      } catch (error) {}
    }
  }

  function computeCartAbandonment(funnelStage) {
    var addToCartPrediction = funnelStage.find( // The pipeline doesn't normalize the funnel stage values so we check it
    // against lowercase to support more cases.
    function (x) {
      return x.name.toLocaleLowerCase() === 'add_to_cart';
    }); // The `add_to_cart` funnel stage doesn't exist so that's not a cart abandonment
    // scenario.

    if (!addToCartPrediction) {
      return 0;
    }

    if (addToCartPrediction.probability >= // We don't use spread in the function call because Babel transformations blow
    // up the bundle size. Once we have more code that requires this syntax,
    // we can consider upgrading to:
    // Math.max(...funnelStage.map((stage) => stage.probability)) // not used for bundle optimization
    Math.max.apply(null, funnelStage.map(function (stage) {
      return stage.probability;
    }))) {
      // The `add_to_cart` prediction is the prediction that has the highest probability,
      // so this is a cart abandonment scenario.
      return 1;
    } else {
      return 0;
    }
  }

  /* eslint-disable no-console */

  /**
   * Logs a debug message.
   * This is used to log debugging messages in development environment only.
   */
  function logDebug(message) {
    var _console;

    var sanitizedMessage = message.trim();

    for (var _len = arguments.length, parts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      parts[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["[Predict] ".concat(sanitizedMessage)].concat(parts));
  }

  function isModelError(prediction) {
    return Boolean(prediction.error);
  }
  /**
   * Unwraps the prediction value, or falls back when it's unavailable.
   *
   * If the model is unavailable, it returns the fallback and triggers a warning.
   */


  function unwrapPrediction(predictions, model, fallback) {
    var prediction = predictions && predictions[model];

    if (!prediction) {
      return fallback;
    }

    if (isModelError(prediction)) {
      "development" !== 'production' ? warn(false, prediction.error) : void 0 ;
      return fallback;
    }

    return prediction.value;
  }

  function ownKeys$4(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }
  function runAction(message, _ref) {
    var init = _ref.init,
        highlighter = _ref.highlighter,
        personifier = _ref.personifier;
    var type = message.type,
        data = message.data;
    var actions = {
      'request-init': function requestInit() {
        // Answer back to the Predict Tools that just opened.
        init();
      },
      'request-highlight-zone': function requestHighlightZone(_ref2) {
        var zoneId = _ref2.zoneId,
            params = _ref2.params;
        var predictZoneElement = document.querySelector("[data-predictzoneid=\"".concat(zoneId, "\"]"));

        if (predictZoneElement) {
          highlighter.select(predictZoneElement, _objectSpread$4({
            id: zoneId
          }, params));
        }
      },
      'request-unhighlight-zone': function requestUnhighlightZone(_ref3) {
        var zoneId = _ref3.zoneId;
        highlighter.unselect(zoneId);
      },
      'request-scroll-to-zone': function requestScrollToZone(_ref4) {
        var zoneId = _ref4.zoneId;
        var predictZoneElement = document.querySelector("[data-predictzoneid=\"".concat(zoneId, "\"]"));

        if (predictZoneElement) {
          var element = predictZoneElement;

          if (element.scrollIntoViewIfNeeded) {
            element.scrollIntoViewIfNeeded();
          } else {
            predictZoneElement.scrollIntoView();
          }
        }
      },
      'request-personification-start': function requestPersonificationStart(_ref5) {
        var userProfile = _ref5.userProfile;
        personifier.start({
          userProfile: userProfile
        });
      },
      'request-personification-end': function requestPersonificationEnd() {
        personifier.end();
      },
      disconnect: function disconnect() {
        highlighter.unselectAll();
      }
    };
    var action = actions[type];
    invariant(Boolean(action), "The Predict Tools event \"".concat(type, "\" is not implemented.")); // @ts-ignore At this point we know that we're manipulating the right data

    action(data);
  }

  function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function createElementHighlighter() {
    var highlights = {};

    function unselect(id) {
      var overlay = highlights[id];

      if (overlay) {
        document.body.removeChild(overlay);
        delete highlights[id];
      }
    }

    return {
      select: function select(referenceElement, props) {
        if (highlights[props.id]) {
          // Ignore if the element is already highlighted
          return;
        }

        var _referenceElement$get = referenceElement.getBoundingClientRect(),
            height = _referenceElement$get.height,
            width = _referenceElement$get.width,
            top = _referenceElement$get.top,
            left = _referenceElement$get.left;

        var overlay = document.createElement('div');
        overlay.setAttribute('data-predicthighlightid', props.id);

        var style = _objectSpread$3(_objectSpread$3({}, props.style), {}, {
          top: "".concat(top, "px"),
          left: "".concat(left, "px"),
          height: "".concat(height, "px"),
          width: "".concat(width, "px")
        });

        Object.keys(style).forEach(function (attribute) {
          overlay.style[attribute] = style[attribute];
        });
        highlights[props.id] = overlay;
        document.body.appendChild(overlay);
      },
      unselect: unselect,
      unselectAll: function unselectAll() {
        Object.keys(highlights).forEach(function (id) {
          return unselect(id);
        });
      }
    };
  }

  var STORAGE_KEY_PREFIX = 'predict';
  var STORAGE_TEST_KEY = "".concat(STORAGE_KEY_PREFIX, "/test-key");

  function isStorageSupported(storage) {
    try {
      storage.setItem(STORAGE_TEST_KEY, '');
      storage.removeItem(STORAGE_TEST_KEY);
      return true;
    } catch (error) {
      return false;
    }
  }

  function createInMemoryStorage() {
    return {
      get: function get() {
        return null;
      },
      set: function set() {},
      remove: function remove() {}
    };
  }

  function createStorage(_ref) {
    var key = _ref.key,
        storage = _ref.storage;

    if (!isStorageSupported(storage)) {
      return createInMemoryStorage();
    }

    var storageKey = "".concat(STORAGE_KEY_PREFIX, "/").concat(key);
    return {
      get: function get() {
        var item = storage.getItem(storageKey);
        return item ? JSON.parse(item) : null;
      },
      set: function set(value) {
        storage.setItem(storageKey, JSON.stringify(value));
      },
      remove: function remove() {
        storage.removeItem(storageKey);
      }
    };
  }

  function createSessionStorage(_ref2) {
    var key = _ref2.key;
    return createStorage({
      key: key,
      storage: sessionStorage
    });
  }

  function createPersonifier(_ref) {
    var onPersonificationStart = _ref.onPersonificationStart,
        onPersonificationEnd = _ref.onPersonificationEnd;
    var personificationSessionStorage = createSessionStorage({
      key: 'tools/userProfile'
    });
    var personifiedUserProfile = personificationSessionStorage.get();

    var _isPersonifying = Boolean(personifiedUserProfile);

    var api = {
      isPersonifying: function isPersonifying() {
        return _isPersonifying;
      },
      start: function start(_ref2) {
        var userProfile = _ref2.userProfile;
        logDebug("Personification started with user \"".concat(userProfile.user, "\"."));
        _isPersonifying = true;
        onPersonificationStart({
          userProfile: userProfile
        });
        personificationSessionStorage.set(userProfile);
      },
      end: function end() {
        logDebug('Personification ended.');
        _isPersonifying = false;
        onPersonificationEnd();
        personificationSessionStorage.remove();
      },
      loadUserProfileFromStorage: function loadUserProfileFromStorage() {
        if (personifiedUserProfile) {
          // To avoid hydration mismatches errors in SSR frameworks like React,
          // we need to start the personification after the first browser render.
          // Unfortunately this means that there's a first render with the actual
          // user profile, and then an update in the next microtask to override it
          // with the personified user profile, resulting in a UI flash.
          // Ideally, we should find a way to override the user profile directly
          // without the hydration warning.
          // See https://beta.reactjs.org/apis/react-dom/client/hydrateRoot#handling-different-client-and-server-content
          queueMicrotask(function () {
            api.start({
              userProfile: personifiedUserProfile
            });
          });
        }
      }
    };
    return api;
  }

  var PREDICT_TO_EXTENSION = 'predict-to-extension';
  var EXTENSION_TO_PREDICT = 'extension-to-predict';

  var _excluded$3 = ["eventType"];

  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  var sendMessage = function sendMessage(message) {
    window.postMessage(_objectSpread$2({
      source: PREDICT_TO_EXTENSION
    }, message), '*');
  };

  function initPredictTools(_ref) {
    var version = _ref.version,
        getContext = _ref.getContext,
        subscribe = _ref.subscribe,
        startPersonification = _ref.startPersonification,
        endPersonification = _ref.endPersonification;
    var highlighter = createElementHighlighter();
    var personifier = createPersonifier({
      onPersonificationStart: startPersonification,
      onPersonificationEnd: endPersonification
    });
    personifier.loadUserProfileFromStorage();
    /**
     * Notifies the Predict Tools from the Predict context.
     */

    function init() {
      sendMessage({
        type: 'init',
        data: {
          version: version,
          context: getContext(),
          isPersonifying: personifier.isPersonifying()
        }
      });
    } // We initialize the Predict Tools right away if the browser's DevTools are open.


    init(); // And we send any state change updates to the Predict Tools.

    subscribe(function (_ref2) {
      _ref2.eventType;
          var context = _objectWithoutProperties(_ref2, _excluded$3);

      sendMessage({
        type: 'state-change',
        data: {
          version: version,
          context: context,
          isPersonifying: personifier.isPersonifying()
        }
      });
    }); // Then, we listen to messages coming from the Predict Tools.

    window.addEventListener('message', function (event) {
      if (event.data.source === EXTENSION_TO_PREDICT) {
        runAction(event.data, {
          init: init,
          highlighter: highlighter,
          personifier: personifier
        });
      }
    });
  }

  var version$1 = '1.6.1';

  function predict(params) {
    var PREDICT_TOOLS_ENABLED = typeof window !== 'undefined';
    var subscribers = [];
    var userProfile = params.userProfile;
    var zones = [];
    var isPersonificationEnabled = false;
    /**
     * Maintains a queue of updates that need to be applied once the personification ends.
     *
     * We ignore `update()` calls when personifying to give precedence to the personified user profile.
     * So we need to apply the updates at the end of the personification to ensure
     * the latest changes are reflected.
     */

    var pendingUpdates = [];

    var applyUpdate = function applyUpdate(nextParams) {
      if (nextParams.userProfile) {
        userProfile = nextParams.userProfile;
      }
    };

    var update = function update(nextParams) {
      if (PREDICT_TOOLS_ENABLED) {
        if (isPersonificationEnabled) {
          logDebug('Skipped update because the Predict Tools extension is personifying the user.', nextParams);
          pendingUpdates.push(nextParams);
          return;
        }
      }

      applyUpdate(nextParams);
      notify('UPDATED');
    };

    var getUserProfile = function getUserProfile() {
      return userProfile;
    };

    var getSegments = function getSegments() {
      return Object.entries(userProfile.segments || {}).reduce(function (acc, segment) {
        // We don't use array destructuring because Babel transformations blow
        // up the bundle size. Once we have more code that requires this syntax,
        // we can consider upgrading to:
        // const [type, names] = segment; // not used for bundle optimization
        var type = segment[0];
        var names = segment[1];
        var segmentsInType = names.map(function (name) {
          return {
            name: name,
            type: type
          };
        });
        segmentsInType.forEach(function (segmentInType) {
          acc.push(segmentInType);
        });
        return acc;
      }, []);
    };

    var getProperties = function getProperties() {
      return Object.entries(userProfile.properties || {}).reduce(function (acc, group) {
        // const [type, properties] = group; // not used for bundle optimization
        var type = group[0];
        var properties = group[1];
        var propertiesInType = Object.entries(properties || {}).map(function (property) {
          // const [key, value] = property; // not used for bundle optimization
          var key = property[0];
          var value = property[1];
          return {
            name: key,
            value: value,
            type: type
          };
        });
        propertiesInType.forEach(function (propertyInType) {
          acc.push(propertyInType);
        });
        return acc;
      }, []);
    };

    var getAffinities = function getAffinities() {
      return unwrapPrediction(userProfile.predictions, 'affinities', []);
    };

    var getFunnelStage = function getFunnelStage() {
      return unwrapPrediction(userProfile.predictions, 'funnel_stage', []);
    };

    var getOrderValue = function getOrderValue() {
      return unwrapPrediction(userProfile.predictions, 'order_value', undefined);
    };

    var getCartAbandonment = function getCartAbandonment() {
      return computeCartAbandonment(getFunnelStage());
    };

    var getZones = function getZones() {
      return zones;
    };

    var addZone = function addZone(newZone) {
      invariant(!zones.some(function (zone) {
        return zone.id === newZone.id;
      }), "Cannot add zone with ID \"".concat(newZone.id, "\" because it already exists."));
      zones.push(newZone);
      notify('ZONE_ADDED');
      return newZone;
    };

    var removeZone = function removeZone(zone) {
      var zoneIndex = zones.findIndex(function (x) {
        return x.id === zone.id;
      });
      invariant(zoneIndex !== -1, "Cannot remove zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
      zones.splice(zoneIndex, 1);
      notify('ZONE_REMOVED');
    };

    var updateZone = function updateZone(zone) {
      var _zone$name, _zone$active, _zone$happened;

      var zoneIndex = zones.findIndex(function (x) {
        return x.id === zone.id;
      });
      invariant(zoneIndex !== -1, "Cannot update zone with ID \"".concat(zone.id, "\" because it doesn't exist."));
      var prevZone = zones[zoneIndex];
      var updatedZone = {
        id: zone.id,
        name: (_zone$name = zone.name) !== null && _zone$name !== void 0 ? _zone$name : prevZone.name,
        active: (_zone$active = zone.active) !== null && _zone$active !== void 0 ? _zone$active : prevZone.active,
        happened: (_zone$happened = zone.happened) !== null && _zone$happened !== void 0 ? _zone$happened : prevZone.happened
      };
      zones[zoneIndex] = updatedZone;
      notify('ZONE_UPDATED');
      return updatedZone;
    };

    var subscribe = function subscribe(subscriber) {
      subscribers.push(subscriber);
      return function () {
        subscribers = subscribers.filter(function (x) {
          return x !== subscriber;
        });
      };
    };

    function notify(eventType) {
      subscribers.forEach(function (subscriber) {
        subscriber({
          eventType: eventType,
          affinities: getAffinities(),
          cartAbandonment: getCartAbandonment(),
          funnelStage: getFunnelStage(),
          orderValue: getOrderValue(),
          segments: getSegments(),
          properties: getProperties(),
          userProfile: getUserProfile(),
          zones: getZones()
        });
      });
    } // Predict Tools are enabled in development mode, or when the `PREDICT_TOOLS`
    // environment variable is set. This is useful to use the web extension in
    // staging environments.


    if (PREDICT_TOOLS_ENABLED) {
      initPredictTools({
        version: version$1,
        subscribe: subscribe,
        getContext: function getContext() {
          return {
            affinities: getAffinities(),
            cartAbandonment: getCartAbandonment(),
            funnelStage: getFunnelStage(),
            orderValue: getOrderValue(),
            segments: getSegments(),
            properties: getProperties(),
            userProfile: getUserProfile(),
            zones: getZones()
          };
        },
        startPersonification: function startPersonification(_ref) {
          var userProfileToPersonify = _ref.userProfile;
          pendingUpdates.push({
            userProfile: userProfile
          });
          update({
            userProfile: userProfileToPersonify
          });
          isPersonificationEnabled = true;
        },
        endPersonification: function endPersonification() {
          isPersonificationEnabled = false;

          while (pendingUpdates.length > 0) {
            var updateParams = pendingUpdates.shift();
            applyUpdate(updateParams);
          } // We trigger an update to notify subscribers.


          update({});
        }
      });
    }

    var api = {
      getAffinities: getAffinities,
      getFunnelStage: getFunnelStage,
      getOrderValue: getOrderValue,
      getCartAbandonment: getCartAbandonment,
      getSegments: getSegments,
      getProperties: getProperties,
      getUserProfile: getUserProfile,
      getZones: getZones,
      update: update,
      addZone: addZone,
      removeZone: removeZone,
      updateZone: updateZone,
      subscribe: subscribe
    };
    return api;
  }

  var has = Object.prototype.hasOwnProperty;

  function dequal(foo, bar) {
  	var ctor, len;
  	if (foo === bar) return true;

  	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
  		if (ctor === Date) return foo.getTime() === bar.getTime();
  		if (ctor === RegExp) return foo.toString() === bar.toString();

  		if (ctor === Array) {
  			if ((len=foo.length) === bar.length) {
  				while (len-- && dequal(foo[len], bar[len]));
  			}
  			return len === -1;
  		}

  		if (!ctor || typeof foo === 'object') {
  			len = 0;
  			for (ctor in foo) {
  				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
  				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
  			}
  			return Object.keys(bar).length === len;
  		}
  	}

  	return foo !== foo && bar !== bar;
  }

  var shim = {exports: {}};

  var useSyncExternalStoreShim_development = {};

  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    (function () {
      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }

      var React = React__default["default"];
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            printWarning('error', format, args);
          }
        }
      }

      function printWarning(level, format, args) {
        // When changing this logic, you might want to also
        // update consoleWithStackDev.www.js as well.
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();

          if (stack !== '') {
            format += '%s';
            args = args.concat([stack]);
          } // eslint-disable-next-line react-internal/safe-string-coercion


          var argsWithFormat = args.map(function (item) {
            return String(item);
          }); // Careful: RN currently depends on this prefix

          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
          // breaks IE9: https://github.com/facebook/react/issues/13610
          // eslint-disable-next-line react-internal/no-production-logging

          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      /**
       * inlined Object.is polyfill to avoid requiring consumers ship their own
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
       */


      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
      }

      var objectIs = typeof Object.is === 'function' ? Object.is : is; // dispatch for CommonJS interop named imports.

      var useState = React.useState,
          useEffect = React.useEffect,
          useLayoutEffect = React.useLayoutEffect,
          useDebugValue = React.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
      // because of a very particular set of implementation details and assumptions
      // -- change any one of them and it will break. The most important assumption
      // is that updates are always synchronous, because concurrent rendering is
      // only available in versions of React that also have a built-in
      // useSyncExternalStore API. And we only use this shim when the built-in API
      // does not exist.
      //
      // Do not assume that the clever hacks used by this hook also work in general.
      // The point of this shim is to replace the need for hacks by other libraries.

      function useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
      // React do not expose a way to check if we're hydrating. So users of the shim
      // will need to track that themselves and return the correct value
      // from `getSnapshot`.
      getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React.startTransition !== undefined) {
              didWarnOld18Alpha = true;
              error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
            }
          }
        } // Read the current snapshot from the store on every render. Again, this
        // breaks the rules of React, and only works here because of specific
        // implementation details, most importantly that updates are
        // always synchronous.

        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();

            if (!objectIs(value, cachedValue)) {
              error('The result of getSnapshot should be cached to avoid an infinite loop');
              didWarnUncachedGetSnapshot = true;
            }
          }
        } // Because updates are synchronous, we don't queue them. Instead we force a
        // re-render whenever the subscribed state changes by updating an some
        // arbitrary useState hook. Then, during render, we call getSnapshot to read
        // the current value.
        //
        // Because we don't actually use the state returned by the useState hook, we
        // can save a bit of memory by storing other stuff in that slot.
        //
        // To implement the early bailout, we need to track some things on a mutable
        // object. Usually, we would put that in a useRef hook, but we can stash it in
        // our useState hook instead.
        //
        // To force a re-render, we call forceUpdate({inst}). That works because the
        // new object always fails an equality check.

        var _useState = useState({
          inst: {
            value: value,
            getSnapshot: getSnapshot
          }
        }),
            inst = _useState[0].inst,
            forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
        // in the layout phase so we can access it during the tearing check that
        // happens on subscribe.


        useLayoutEffect(function () {
          inst.value = value;
          inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
          // commit phase if there was an interleaved mutation. In concurrent mode
          // this can happen all the time, but even in synchronous mode, an earlier
          // effect may have mutated the store.

          if (checkIfSnapshotChanged(inst)) {
            // Force a re-render.
            forceUpdate({
              inst: inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect(function () {
          // Check for changes right before subscribing. Subsequent changes will be
          // detected in the subscription handler.
          if (checkIfSnapshotChanged(inst)) {
            // Force a re-render.
            forceUpdate({
              inst: inst
            });
          }

          var handleStoreChange = function handleStoreChange() {
            // TODO: Because there is no cross-renderer API for batching updates, it's
            // up to the consumer of this library to wrap their subscription event
            // with unstable_batchedUpdates. Should we try to detect when this isn't
            // the case and print a warning in development?
            // The store changed. Check if the snapshot changed since the last time we
            // read from the store.
            if (checkIfSnapshotChanged(inst)) {
              // Force a re-render.
              forceUpdate({
                inst: inst
              });
            }
          }; // Subscribe to the store and return a clean-up function.


          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue(value);
        return value;
      }

      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;

        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error) {
          return true;
        }
      }

      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        // Note: The shim does not use getServerSnapshot, because pre-18 versions of
        // React do not expose a way to check if we're hydrating. So users of the shim
        // will need to track that themselves and return the correct value
        // from `getSnapshot`.
        return getSnapshot();
      }

      var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
      var isServerEnvironment = !canUseDOM;
      var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }

  (function (module) {

    {
      module.exports = useSyncExternalStoreShim_development;
    }
  })(shim);

  var PredictContext = /*#__PURE__*/React.createContext(null);

  {
    PredictContext.displayName = 'Predict';
  }

  var _excluded$2 = ["eventType"];

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function Predict(_ref) {
    var userProfile = _ref.userProfile,
        _ref$suppressExperime = _ref.suppressExperimentalWarning,
        suppressExperimentalWarning = _ref$suppressExperime === void 0 ? false : _ref$suppressExperime,
        children = _ref.children;
    var predictRef = React.useRef(null);

    if (predictRef.current === null) {
      predictRef.current = predict({
        userProfile: userProfile
      });
    }

    var _useState = React.useState(function () {
      return {
        userProfile: predictRef.current.getUserProfile(),
        affinities: predictRef.current.getAffinities(),
        funnelStage: predictRef.current.getFunnelStage(),
        orderValue: predictRef.current.getOrderValue(),
        cartAbandonment: predictRef.current.getCartAbandonment(),
        segments: predictRef.current.getSegments(),
        properties: predictRef.current.getProperties(),
        zones: predictRef.current.getZones(),
        addZone: predictRef.current.addZone,
        removeZone: predictRef.current.removeZone,
        updateZone: predictRef.current.updateZone,
        subscribe: predictRef.current.subscribe
      };
    }),
        _useState2 = _slicedToArray(_useState, 2),
        predictApi = _useState2[0],
        setPredictApi = _useState2[1];

    var _useState3 = React.useState(function () {
      return predictRef.current.getUserProfile();
    }),
        _useState4 = _slicedToArray(_useState3, 2),
        prevUserProfile = _useState4[0],
        setPrevUserProfile = _useState4[1];

    if (!dequal(userProfile, prevUserProfile)) {
      predictRef.current.update({
        userProfile: userProfile
      });
      setPrevUserProfile(userProfile);
    }

    var store = shim.exports.useSyncExternalStore(React.useCallback(function () {
      return predictRef.current.subscribe(function (_ref2) {
        var eventType = _ref2.eventType,
            state = _objectWithoutProperties(_ref2, _excluded$2);

        // We manage zone updates directly with the React state, so we don't
        // need to listen to this event.
        if (eventType !== 'ZONE_UPDATED') {
          setPredictApi(function (prev) {
            return _objectSpread$1(_objectSpread$1({}, prev), state);
          });
        }
      });
    }, []), function () {
      return predictApi;
    }, function () {
      return predictApi;
    });
    React.useEffect(function () {
      "development" !== 'production' ? warn(suppressExperimentalWarning, 'This version is experimental and not production-ready.\n\n' + 'Please report any bugs at https://github.com/algolia/predict/issues/new\n\n' + '(To disable this warning, pass `suppressExperimentalWarning` to <Predict>.)') : void 0;
    }, [suppressExperimentalWarning]);
    return /*#__PURE__*/React__default["default"].createElement(PredictContext.Provider, {
      value: store
    }, children);
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var PredictZoneContext = /*#__PURE__*/React.createContext(null);

  {
    PredictZoneContext.displayName = 'PredictZone';
  }

  function usePredictContext() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$errorMessage = _ref.errorMessage,
        errorMessage = _ref$errorMessage === void 0 ? 'The Predict APIs must be used within the <Predict> provider.' : _ref$errorMessage;

    var context = React.useContext(PredictContext);
    invariant(context !== null, errorMessage);
    return context;
  }

  function useStableValue(value) {
    var _useState = React.useState(function () {
      return value;
    }),
        _useState2 = _slicedToArray(_useState, 2),
        stableValue = _useState2[0],
        setStableValue = _useState2[1];

    if (!dequal(stableValue, value)) {
      setStableValue(value);
    }

    return stableValue;
  }

  var _excluded$1 = ["addZone", "removeZone", "updateZone", "subscribe"];
  function usePredict() {
    var _usePredictContext = usePredictContext({
      errorMessage: '`usePredict()` must be used within the <Predict> provider.'
    });
        _usePredictContext.addZone;
        _usePredictContext.removeZone;
        _usePredictContext.updateZone;
        _usePredictContext.subscribe;
        var rest = _objectWithoutProperties(_usePredictContext, _excluded$1);

    var predictApi = useStableValue(rest);
    return predictApi;
  }

  var _excluded = ["id", "children", "name", "segment", "fallback"];

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function PredictZone(_ref) {
    var id = _ref.id,
        children = _ref.children,
        name = _ref.name,
        segment = _ref.segment,
        _ref$fallback = _ref.fallback,
        fallback = _ref$fallback === void 0 ? null : _ref$fallback,
        props = _objectWithoutProperties(_ref, _excluded);

    var _usePredictContext = usePredictContext({
      errorMessage: 'The <PredictZone> must be mounted within the <Predict> provider.'
    }),
        addZone = _usePredictContext.addZone,
        removeZone = _usePredictContext.removeZone,
        updateZone = _usePredictContext.updateZone;

    var predictApi = usePredict();

    var _useState = React.useState(function () {
      var active = // eslint-disable-next-line no-nested-ternary
      typeof segment === 'function' ? segment(predictApi) : segment ? Boolean(predictApi.segments.find(function (s) {
        return s.name === segment;
      })) : true;
      return createZone({
        id: id,
        name: name,
        active: active
      });
    }),
        _useState2 = _slicedToArray(_useState, 2),
        zone = _useState2[0],
        setZone = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        isDismissed = _useState4[0],
        setIsDismissed = _useState4[1];

    var _useState5 = React.useState(zone.name),
        _useState6 = _slicedToArray(_useState5, 2),
        prevName = _useState6[0],
        setPrevName = _useState6[1];

    if (name !== prevName) {
      setPrevName(name);
      updateZone({
        id: zone.id,
        name: name
      });
    }

    if (!isDismissed) {
      var active = // eslint-disable-next-line no-nested-ternary
      typeof segment === 'function' ? segment(predictApi) : segment ? Boolean(predictApi.segments.find(function (s) {
        return s.name === segment;
      })) : zone.active;

      if (active !== zone.active) {
        setZone(function (prev) {
          return _objectSpread(_objectSpread({}, prev), {}, {
            active: active
          });
        });
        updateZone({
          id: zone.id,
          active: active
        });
      }
    }

    var zoneApi = React.useMemo(function () {
      return {
        dismissZone: function dismissZone() {
          setZone(function (prev) {
            return _objectSpread(_objectSpread({}, prev), {}, {
              active: false,
              happened: true
            });
          });
          updateZone({
            id: zone.id,
            active: false,
            happened: true
          });
          setIsDismissed(true);
        }
      };
    }, [updateZone, zone.id]);
    var zoneStore = shim.exports.useSyncExternalStore(React.useCallback(function () {
      addZone(zone);
      return function () {
        removeZone(zone);
      }; // We don't track zone changes because we update the zone in the store via
      // `updateZone()`.
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [addZone, removeZone]), function () {
      return zoneApi;
    }, function () {
      return zoneApi;
    });

    if (!zone.active) {
      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, fallback);
    }

    return /*#__PURE__*/React__default["default"].createElement(PredictZoneContext.Provider, {
      value: zoneStore
    }, /*#__PURE__*/React__default["default"].createElement("div", _extends({}, props, {
      "data-predictzoneid": zone.id,
      onMouseDown: function onMouseDown() {
        setZone(function (prev) {
          return _objectSpread(_objectSpread({}, prev), {}, {
            happened: true
          });
        });
        updateZone({
          id: zone.id,
          happened: true
        });
      },
      onTouchStart: function onTouchStart() {
        setZone(function (prev) {
          return _objectSpread(_objectSpread({}, prev), {}, {
            happened: true
          });
        });
        updateZone({
          id: zone.id,
          happened: true
        });
      }
    }), children));
  }

  function usePredictZone() {
    var context = React.useContext(PredictZoneContext);
    invariant(context !== null, '`usePredictZone()` must be used within a <PredictZone>.');
    return context;
  }

  var version = '1.6.1';

  exports.Predict = Predict;
  exports.PredictZone = PredictZone;
  exports.usePredict = usePredict;
  exports.usePredictZone = usePredictZone;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
