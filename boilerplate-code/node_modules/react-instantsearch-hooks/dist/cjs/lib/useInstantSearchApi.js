"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInstantSearchApi = useInstantSearchApi;

var _InstantSearch = _interopRequireDefault(require("instantsearch.js/cjs/lib/InstantSearch"));

var _react = require("react");

var _shim = require("use-sync-external-store/shim");

var _useInstantSearchServerContext = require("../lib/useInstantSearchServerContext");

var _useInstantSearchSSRContext = require("../lib/useInstantSearchSSRContext");

var _version = _interopRequireDefault(require("../version"));

var _useForceUpdate = require("./useForceUpdate");

var defaultUserAgents = ["react (".concat(_react.version, ")"), "react-instantsearch (".concat(_version.default, ")"), "react-instantsearch-hooks (".concat(_version.default, ")")];
var serverUserAgent = "react-instantsearch-server (".concat(_version.default, ")");

function useInstantSearchApi(props) {
  var forceUpdate = (0, _useForceUpdate.useForceUpdate)();
  var serverContext = (0, _useInstantSearchServerContext.useInstantSearchServerContext)();
  var serverState = (0, _useInstantSearchSSRContext.useInstantSearchSSRContext)();
  var initialResults = serverState === null || serverState === void 0 ? void 0 : serverState.initialResults;
  var searchRef = (0, _react.useRef)(null);
  var prevPropsRef = (0, _react.useRef)(props);

  if (searchRef.current === null) {
    // We don't use the `instantsearch()` function because it comes with other
    // top-level APIs that we don't need.
    // See https://github.com/algolia/instantsearch.js/blob/5b529f43d8acc680f85837eaaa41f7fd03a3f833/src/index.es.ts#L63-L86
    var search = new _InstantSearch.default(props);

    if (serverContext || initialResults) {
      // InstantSearch.js has a private Initial Results API that lets us inject
      // results on the search instance.
      // On the server, we default the initial results to an empty object so that
      // InstantSearch.js doesn't schedule a search that isn't used, leading to
      // an additional network request. (This is equivalent to monkey-patching
      // `scheduleSearch` to a noop.)
      search._initialResults = initialResults || {};
    }

    addAlgoliaAgents(props.searchClient, [].concat(defaultUserAgents, [serverContext && serverUserAgent])); // On the server, we start the search early to compute the search parameters.
    // On SSR, we start the search early to directly catch up with the lifecycle
    // and render.

    if (serverContext || initialResults) {
      search.start();
    }

    if (serverContext) {
      // We notify `getServerState()` of the InstantSearch internals to retrieve
      // the server state and pass it to the render on SSR.
      serverContext.notifyServer({
        search: search
      });
    }

    searchRef.current = search;
  }

  {
    var _search = searchRef.current;
    var prevProps = prevPropsRef.current;

    if (prevProps.indexName !== props.indexName) {
      _search.helper.setIndex(props.indexName).search();

      prevPropsRef.current = props;
    }

    if (prevProps.searchClient !== props.searchClient) {
      addAlgoliaAgents(props.searchClient, [].concat(defaultUserAgents, [serverContext && serverUserAgent]));

      _search.mainHelper.setClient(props.searchClient).search();

      prevPropsRef.current = props;
    }

    if (prevProps.onStateChange !== props.onStateChange) {
      _search.onStateChange = props.onStateChange;
      prevPropsRef.current = props;
    }

    if (prevProps.searchFunction !== props.searchFunction) {
      // Updating the `searchFunction` to `undefined` is not supported by
      // InstantSearch.js, so it will throw an error.
      // This is a fair behavior until we add an update API in InstantSearch.js.
      _search._searchFunction = props.searchFunction;
      prevPropsRef.current = props;
    }

    if (prevProps.stalledSearchDelay !== props.stalledSearchDelay) {
      var _props$stalledSearchD;

      // The default `stalledSearchDelay` in InstantSearch.js is 200ms.
      // We need to reset it when it's undefined to get back to the original value.
      _search._stalledSearchDelay = (_props$stalledSearchD = props.stalledSearchDelay) !== null && _props$stalledSearchD !== void 0 ? _props$stalledSearchD : 200;
      prevPropsRef.current = props;
    } // Updating the `routing` prop is not supported because InstantSearch.js
    // doesn't let us change it. This might not be a problem though, because `routing`
    // shouldn't need to be dynamic.
    // If we find scenarios where `routing` needs to change, we can always expose
    // it privately on the InstantSearch instance. Another way would be to
    // manually inject the routing middleware in this library, and not rely
    // on the provided `routing` prop.

  }
  var cleanupTimerRef = (0, _react.useRef)(null);
  var store = (0, _shim.useSyncExternalStore)((0, _react.useCallback)(function () {
    var search = searchRef.current; // Scenario 1: the component mounts.

    if (cleanupTimerRef.current === null) {
      // On SSR, the instance is already started so we don't start it again.
      if (!search.started) {
        search.start();
        forceUpdate();
      }
    } // Scenario 2: the component updates.
    else {
      // We cancel the previous cleanup function because we don't want to
      // dispose the search during an update.
      clearTimeout(cleanupTimerRef.current);
      search._preventWidgetCleanup = false;
    }

    return function () {
      function cleanup() {
        search.dispose();
      } // We clean up only when the component that uses this subscription unmounts,
      // but not when it updates, because it would dispose the instance, which
      // would remove all the widgets and break routing.
      // Executing the cleanup function in a `setTimeout()` lets us cancel it
      // in the next effect.
      // (There might be better ways to do this.)


      cleanupTimerRef.current = setTimeout(cleanup); // We need to prevent the `useWidget` cleanup function so that widgets
      // are not removed before the instance is disposed, triggering
      // an unwanted search request.

      search._preventWidgetCleanup = true;
    };
  }, [forceUpdate]), function () {
    return searchRef.current;
  }, function () {
    return searchRef.current;
  });
  return store;
}

function addAlgoliaAgents(searchClient, userAgents) {
  if (typeof searchClient.addAlgoliaAgent !== 'function') {
    return;
  }

  userAgents.filter(Boolean).forEach(function (userAgent) {
    searchClient.addAlgoliaAgent(userAgent);
  });
}