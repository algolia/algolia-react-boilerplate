{"version":3,"file":"index.js","sources":["../../src/utils/mapToRecommendations.ts","../../src/utils/computeAverageIndices.ts","../../../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../src/utils/mapByScoreToRecommendations.ts","../../src/utils/sortBy.ts","../../src/version.ts","../../src/getFrequentlyBoughtTogether.ts","../../src/getRecommendations.ts","../../src/getRelatedProducts.ts","../../src/getTrendingFacets.ts","../../src/getTrendingItems.ts","../../src/utils/uniqBy.ts"],"sourcesContent":["import { ProductRecord } from '../types';\nimport { AverageIndices } from '../types/AverageIndices';\nimport { IndexTracker } from '../types/IndexTracker';\n\nimport { getAverageIndices } from './computeAverageIndices';\n\n/**\n * Returns the reordered list of recommendations based on average indices.\n *\n * @param hits - recommendations\n * @param maxRecommendations - max number of recommendations\n * @param nrOfObjs - total number of products for which we are retrieving recommendations (objectsIDs.length)\n */\n\ntype MapToRecommendations<TObject> = {\n  hits: Array<Array<ProductRecord<TObject>>>;\n  maxRecommendations?: number;\n  nrOfObjs: number;\n};\n\nexport function mapToRecommendations<TObject>({\n  hits,\n  maxRecommendations,\n  nrOfObjs,\n}: MapToRecommendations<TObject>) {\n  const indexTracker: IndexTracker = {};\n\n  hits.forEach((hitsArray) => {\n    hitsArray.forEach((hit, index) => {\n      if (!indexTracker[hit.objectID]) {\n        indexTracker[hit.objectID] = { indexSum: index, nr: 1 };\n      } else {\n        indexTracker[hit.objectID] = {\n          indexSum: indexTracker[hit.objectID].indexSum + index,\n          nr: indexTracker[hit.objectID].nr + 1,\n        };\n      }\n    });\n  });\n\n  const sortedAverageIndices = getAverageIndices(indexTracker, nrOfObjs);\n\n  const finalOrder = sortedAverageIndices.reduce<Array<ProductRecord<TObject>>>(\n    (\n      orderedHits: Array<ProductRecord<TObject>>,\n      avgIndexRef: AverageIndices\n    ) => {\n      const result = hits\n        .flat()\n        .find(\n          (hit: ProductRecord<TObject>) => hit.objectID === avgIndexRef.objectID\n        );\n      return result ? orderedHits.concat(result) : orderedHits;\n    },\n    []\n  );\n\n  return finalOrder.slice(\n    0,\n    // We cap the number of recommendations because the previously\n    // computed `hitsPerPage` was an approximation due to `Math.ceil`.\n    maxRecommendations && maxRecommendations > 0\n      ? maxRecommendations\n      : undefined\n  );\n}\n","import { AverageIndices } from '../types/AverageIndices';\nimport { IndexTracker } from '../types/IndexTracker';\n\nexport const getAverageIndices = (\n  indexTracker: IndexTracker,\n  nrOfObjs: number\n) => {\n  const avgIndices: AverageIndices[] = [];\n\n  for (const key of Object.keys(indexTracker)) {\n    if (indexTracker[key].nr < 2) {\n      indexTracker[key].indexSum += 100;\n    }\n    avgIndices.push({\n      objectID: key,\n      avgOfIndices: indexTracker[key].indexSum / nrOfObjs,\n    });\n  }\n\n  return avgIndices.sort((a, b) => (a.avgOfIndices > b.avgOfIndices ? 1 : -1));\n};\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { sortBy } from './sortBy';\n\ntype MapToRecommendations<TObject> = {\n  hits: Array<TObject & { _score?: number }>;\n  maxRecommendations?: number;\n};\n\nexport function mapByScoreToRecommendations<TObject>({\n  hits,\n  maxRecommendations,\n}: MapToRecommendations<TObject>) {\n  // Since recommendations from multiple indices are returned, we\n  // need to sort them descending based on their score.\n  return sortBy<TObject & { _score?: number }>((a, b) => {\n    const scoreA = a._score || 0;\n    const scoreB = b._score || 0;\n\n    return scoreA > scoreB ? -1 : 1;\n  }, hits).slice(\n    0,\n    // We cap the number of recommendations because the previously\n    // computed `hitsPerPage` was an approximation due to `Math.ceil`.\n    maxRecommendations && maxRecommendations > 0\n      ? maxRecommendations\n      : undefined\n  );\n}\n","type Predicate<TItem> = (a: TItem, b: TItem) => number;\n\nexport function sortBy<TItem>(predicate: Predicate<TItem>, items: TItem[]) {\n  const itemsCopy = [...items];\n  itemsCopy.sort(predicate);\n\n  return itemsCopy;\n}\n","export const version = '1.8.0';\n","import { FrequentlyBoughtTogetherQuery } from '@algolia/recommend';\n\nimport { RecommendationsProps } from './getRecommendations';\nimport { ProductRecord } from './types';\nimport { mapToRecommendations } from './utils';\nimport { version } from './version';\n\nexport type GetFrequentlyBoughtTogetherProps<\n  TObject\n> = RecommendationsProps<TObject> &\n  Omit<FrequentlyBoughtTogetherQuery, 'objectID'>;\n\nexport function getFrequentlyBoughtTogether<TObject>({\n  objectIDs,\n  recommendClient,\n  transformItems = (x) => x,\n  indexName,\n  maxRecommendations,\n  queryParameters,\n  threshold,\n}: GetFrequentlyBoughtTogetherProps<TObject>) {\n  const queries = objectIDs.map((objectID) => ({\n    indexName,\n    maxRecommendations,\n    objectID,\n    queryParameters,\n    threshold,\n  }));\n\n  recommendClient.addAlgoliaAgent('recommend-core', version);\n\n  return recommendClient\n    .getFrequentlyBoughtTogether<TObject>(queries)\n    .then((response) =>\n      mapToRecommendations<ProductRecord<TObject>>({\n        maxRecommendations,\n        hits: response.results.map((result) => result.hits),\n        nrOfObjs: objectIDs.length,\n      })\n    )\n    .then((hits) => ({ recommendations: transformItems(hits) }));\n}\n","import type { RecommendClient, RecommendationsQuery } from '@algolia/recommend';\n\nimport { ProductRecord, RecordWithObjectID } from './types';\nimport { mapToRecommendations } from './utils';\nimport { version } from './version';\n\nexport type RecommendationsProps<TObject> = {\n  /**\n   * The `objectID`s of the items to get recommendations for.\n   */\n  objectIDs: string[];\n  /**\n   * The initialized Algolia recommend client.\n   */\n  recommendClient: RecommendClient;\n  /**\n   * A function to transform the retrieved items before passing them to the component.\n   *\n   * Itâ€™s useful to add or remove items, change them, or reorder them.\n   */\n  transformItems?: (\n    items: Array<ProductRecord<TObject>>\n  ) => Array<ProductRecord<TObject>>;\n};\n\nexport type GetRecommendationsProps<TObject> = RecommendationsProps<TObject> &\n  Omit<RecommendationsQuery, 'objectID'>;\n\nexport type GetRecommendationsResult<TObject> = {\n  recommendations: Array<RecordWithObjectID<TObject>>;\n};\n\nexport function getRecommendations<TObject>({\n  objectIDs,\n  recommendClient,\n  transformItems = (x) => x,\n  fallbackParameters,\n  indexName,\n  maxRecommendations,\n  model,\n  queryParameters,\n  threshold,\n}: GetRecommendationsProps<TObject>): Promise<\n  GetRecommendationsResult<TObject>\n> {\n  const queries = objectIDs.map((objectID) => ({\n    fallbackParameters,\n    indexName,\n    maxRecommendations,\n    model,\n    objectID,\n    queryParameters,\n    threshold,\n  }));\n\n  recommendClient.addAlgoliaAgent('recommend-core', version);\n\n  return recommendClient\n    .getRecommendations<TObject>(queries)\n    .then((response) =>\n      mapToRecommendations<ProductRecord<TObject>>({\n        maxRecommendations,\n        hits: response.results.map((result) => result.hits),\n        nrOfObjs: objectIDs.length,\n      })\n    )\n    .then((hits) => ({ recommendations: transformItems(hits) }));\n}\n","import { RelatedProductsQuery } from '@algolia/recommend';\n\nimport { RecommendationsProps } from './getRecommendations';\nimport { ProductRecord } from './types';\nimport { mapToRecommendations } from './utils';\nimport { version } from './version';\n\nexport type GetRelatedProductsProps<TObject> = RecommendationsProps<TObject> &\n  Omit<RelatedProductsQuery, 'objectID'>;\n\nexport function getRelatedProducts<TObject>({\n  objectIDs,\n  recommendClient,\n  transformItems = (x) => x,\n  fallbackParameters,\n  indexName,\n  maxRecommendations,\n  queryParameters,\n  threshold,\n}: GetRelatedProductsProps<TObject>) {\n  const queries = objectIDs.map((objectID) => ({\n    fallbackParameters,\n    indexName,\n    maxRecommendations,\n    objectID,\n    queryParameters,\n    threshold,\n  }));\n\n  recommendClient.addAlgoliaAgent('recommend-core', version);\n\n  return recommendClient\n    .getRelatedProducts<TObject>(queries)\n    .then((response) =>\n      mapToRecommendations<ProductRecord<TObject>>({\n        maxRecommendations,\n        hits: response.results.map((result) => result.hits),\n        nrOfObjs: objectIDs.length,\n      })\n    )\n    .then((hits) => ({ recommendations: transformItems(hits) }));\n}\n","import { RecommendClient, TrendingFacetsQuery } from '@algolia/recommend';\n\nimport { TrendingFacet } from './types';\nimport { mapByScoreToRecommendations } from './utils';\nimport { version } from './version';\n\nexport type TrendingFacetsProps<TObject> = {\n  /**\n   * The initialized Algolia recommend client.\n   */\n  recommendClient: RecommendClient;\n  /**\n   * A function to transform the retrieved items before passing them to the component.\n   *\n   * Itâ€™s useful to add or remove items, change them, or reorder them.\n   */\n  transformItems?: (\n    items: Array<TrendingFacet<TObject>>\n  ) => Array<TrendingFacet<TObject>>;\n};\n\nexport type GetTrendingFacetsResult<TObject> = {\n  recommendations: Array<TrendingFacet<TObject>>;\n};\n\nexport type GetTrendingFacetsProps<TObject> = TrendingFacetsProps<TObject> &\n  TrendingFacetsQuery;\n\nexport function getTrendingFacets<TObject>({\n  recommendClient,\n  transformItems = (x) => x,\n  fallbackParameters,\n  indexName,\n  maxRecommendations,\n  queryParameters,\n  threshold,\n  facetName,\n}: GetTrendingFacetsProps<TObject>) {\n  const query = {\n    fallbackParameters,\n    indexName,\n    maxRecommendations,\n    queryParameters,\n    threshold,\n    facetName,\n  };\n\n  recommendClient.addAlgoliaAgent('recommend-core', version);\n\n  return recommendClient\n    .getTrendingFacets<TObject>([query])\n    .then((response) =>\n      mapByScoreToRecommendations<TrendingFacet<TObject>>({\n        maxRecommendations,\n        hits: response.results.map((result) => result.hits).flat(),\n      })\n    )\n    .then((hits) => ({ recommendations: transformItems(hits) }));\n}\n","import { RecommendClient, TrendingItemsQuery } from '@algolia/recommend';\n\nimport { ProductRecord } from './types';\nimport { mapByScoreToRecommendations, uniqBy } from './utils';\nimport { version } from './version';\n\nexport type TrendingItemsProps<TObject> = {\n  /**\n   * The initialized Algolia recommend client.\n   */\n  recommendClient: RecommendClient;\n  /**\n   * A function to transform the retrieved items before passing them to the component.\n   *\n   * Itâ€™s useful to add or remove items, change them, or reorder them.\n   */\n  transformItems?: (\n    items: Array<ProductRecord<TObject>>\n  ) => Array<ProductRecord<TObject>>;\n};\n\nexport type GetTrendingItemsResult<TObject> = {\n  recommendations: Array<ProductRecord<TObject>>;\n};\n\nexport type GetTrendingItemsProps<TObject> = TrendingItemsProps<TObject> &\n  TrendingItemsQuery;\n\nexport function getTrendingItems<TObject>({\n  recommendClient,\n  transformItems = (x) => x,\n  fallbackParameters,\n  indexName,\n  maxRecommendations,\n  queryParameters,\n  threshold,\n  facetName,\n  facetValue,\n}: GetTrendingItemsProps<TObject>) {\n  const query = {\n    fallbackParameters,\n    indexName,\n    maxRecommendations,\n    queryParameters,\n    threshold,\n    facetName,\n    facetValue,\n  };\n\n  recommendClient.addAlgoliaAgent('recommend-core', version);\n\n  return recommendClient\n    .getTrendingItems<TObject>([query])\n    .then((response) =>\n      mapByScoreToRecommendations<ProductRecord<TObject>>({\n        maxRecommendations,\n        // Multiple identical recommended `objectID`s can be returned b\n        // the engine, so we need to remove duplicates.\n        hits: uniqBy<ProductRecord<TObject>>(\n          'objectID',\n          response.results.map((result) => result.hits).flat()\n        ),\n      })\n    )\n    .then((hits) => ({ recommendations: transformItems(hits) }));\n}\n","export function uniqBy<TItem>(key: keyof TItem, items: TItem[]) {\n  return [...new Map(items.map((item) => [item[key], item])).values()];\n}\n"],"names":["mapToRecommendations","hits","maxRecommendations","nrOfObjs","indexTracker","forEach","hitsArray","hit","index","objectID","indexSum","nr","sortedAverageIndices","avgIndices","Object","keys","key","push","avgOfIndices","sort","a","b","getAverageIndices","reduce","orderedHits","avgIndexRef","result","flat","find","concat","slice","undefined","_arrayLikeToArray","arr","len","length","i","arr2","Array","_toConsumableArray","isArray","arrayLikeToArray","arrayWithoutHoles","iter","Symbol","iterator","from","iterableToArray","o","minLen","n","prototype","toString","call","constructor","name","test","unsupportedIterableToArray","TypeError","nonIterableSpread","mapByScoreToRecommendations","predicate","items","itemsCopy","_score","version","objectIDs","recommendClient","transformItems","x","indexName","queryParameters","threshold","queries","map","addAlgoliaAgent","getFrequentlyBoughtTogether","then","response","results","recommendations","fallbackParameters","model","getRecommendations","getRelatedProducts","facetName","query","getTrendingFacets","facetValue","getTrendingItems","Map","item","values"],"mappings":";kQAoBO,SAASA,SACdC,IAAAA,KACAC,IAAAA,mBACAC,IAAAA,SAEMC,EAA6B,GAEnCH,EAAKI,SAAQ,SAACC,GACZA,EAAUD,SAAQ,SAACE,EAAKC,GACjBJ,EAAaG,EAAIE,UAGpBL,EAAaG,EAAIE,UAAY,CAC3BC,SAAUN,EAAaG,EAAIE,UAAUC,SAAWF,EAChDG,GAAIP,EAAaG,EAAIE,UAAUE,GAAK,GAJtCP,EAAaG,EAAIE,UAAY,CAAEC,SAAUF,EAAOG,GAAI,aAUpDC,ECrCyB,SAC/BR,EACAD,WAEMU,EAA+B,SAEnBC,OAAOC,KAAKX,kBAAe,KAAlCY,OACLZ,EAAaY,GAAKL,GAAK,IACzBP,EAAaY,GAAKN,UAAY,KAEhCG,EAAWI,KAAK,CACdR,SAAUO,EACVE,aAAcd,EAAaY,GAAKN,SAAWP,WAIxCU,EAAWM,MAAK,SAACC,EAAGC,UAAOD,EAAEF,aAAeG,EAAEH,aAAe,GAAK,IAC1E,CDoB8BI,CAAkBlB,EAAcD,UAE1CS,EAAqBW,QACtC,SACEC,EACAC,OAEMC,EAASzB,EACZ0B,OACAC,MACC,SAACrB,UAAgCA,EAAIE,WAAagB,EAAYhB,mBAE3DiB,EAASF,EAAYK,OAAOH,GAAUF,IAE/C,IAGgBM,MAChB,EAGA5B,GAAsBA,EAAqB,EACvCA,OACA6B,EAEP,CEjEc,SAASC,EAAkBC,EAAKC,IAClC,MAAPA,GAAeA,EAAMD,EAAIE,UAAQD,EAAMD,EAAIE,YAE1C,IAAIC,EAAI,EAAGC,EAAO,IAAIC,MAAMJ,GAAME,EAAIF,EAAKE,IAC9CC,EAAKD,GAAKH,EAAIG,UAGTC,CACR,CCJc,SAASE,EAAmBN,UCH5B,SAA4BA,MACrCK,MAAME,QAAQP,GAAM,OAAOQ,EAAiBR,EACjD,CDEQS,CAAkBT,IELZ,SAA0BU,MACjB,oBAAXC,QAAmD,MAAzBD,EAAKC,OAAOC,WAA2C,MAAtBF,EAAK,cAAuB,OAAOL,MAAMQ,KAAKH,EACrH,CFGkCI,CAAgBd,IGJpC,SAAqCe,EAAGC,MAChDD,MACY,iBAANA,EAAgB,OAAOP,EAAiBO,EAAGC,OAClDC,EAAIpC,OAAOqC,UAAUC,SAASC,KAAKL,GAAGlB,MAAM,GAAI,SAC1C,WAANoB,GAAkBF,EAAEM,cAAaJ,EAAIF,EAAEM,YAAYC,MAC7C,QAANL,GAAqB,QAANA,EAAoBZ,MAAMQ,KAAKE,GACxC,cAANE,GAAqB,2CAA2CM,KAAKN,GAAWT,EAAiBO,EAAGC,UACzG,CHH0DQ,CAA2BxB,IILvE,iBACP,IAAIyB,UAAU,uIACrB,CJG6FC,EAC7F,CKCM,SAASC,SCLcC,EAA6BC,EACnDC,EDKN9D,IAAAA,KACAC,IAAAA,0BCP4B2D,EDWiB,SAACzC,EAAGC,UAChCD,EAAE4C,QAAU,IACZ3C,EAAE2C,QAAU,IAED,EAAI,GCfyBF,EDgBtD7D,ECfG8D,IAAgBD,GACtBC,EAAU5C,KAAK0C,GAERE,GDYEjC,MACP,EAGA5B,GAAsBA,EAAqB,EACvCA,OACA6B,EAEP,CE1BM,IAAMkC,EAAU,sCCYhB,gBACLC,IAAAA,UACAC,IAAAA,oBACAC,eAAAA,aAAiB,SAACC,UAAMA,KACxBC,IAAAA,UACApE,IAAAA,mBACAqE,IAAAA,gBACAC,IAAAA,UAEMC,EAAUP,EAAUQ,KAAI,SAACjE,SAAc,CAC3C6D,UAAAA,EACApE,mBAAAA,EACAO,SAAAA,EACA8D,gBAAAA,EACAC,UAAAA,aAGFL,EAAgBQ,gBAAgB,iBAAkBV,GAE3CE,EACJS,4BAAqCH,GACrCI,MAAK,SAACC,UACL9E,EAA6C,CAC3CE,mBAAAA,EACAD,KAAM6E,EAASC,QAAQL,KAAI,SAAChD,UAAWA,EAAOzB,QAC9CE,SAAU+D,EAAU/B,YAGvB0C,MAAK,SAAC5E,SAAU,CAAE+E,gBAAiBZ,EAAenE,MACtD,uBCTM,gBACLiE,IAAAA,UACAC,IAAAA,oBACAC,eAAAA,aAAiB,SAACC,UAAMA,KACxBY,IAAAA,mBACAX,IAAAA,UACApE,IAAAA,mBACAgF,IAAAA,MACAX,IAAAA,gBACAC,IAAAA,UAIMC,EAAUP,EAAUQ,KAAI,SAACjE,SAAc,CAC3CwE,mBAAAA,EACAX,UAAAA,EACApE,mBAAAA,EACAgF,MAAAA,EACAzE,SAAAA,EACA8D,gBAAAA,EACAC,UAAAA,aAGFL,EAAgBQ,gBAAgB,iBAAkBV,GAE3CE,EACJgB,mBAA4BV,GAC5BI,MAAK,SAACC,UACL9E,EAA6C,CAC3CE,mBAAAA,EACAD,KAAM6E,EAASC,QAAQL,KAAI,SAAChD,UAAWA,EAAOzB,QAC9CE,SAAU+D,EAAU/B,YAGvB0C,MAAK,SAAC5E,SAAU,CAAE+E,gBAAiBZ,EAAenE,MACtD,uBCzDM,gBACLiE,IAAAA,UACAC,IAAAA,oBACAC,eAAAA,aAAiB,SAACC,UAAMA,KACxBY,IAAAA,mBACAX,IAAAA,UACApE,IAAAA,mBACAqE,IAAAA,gBACAC,IAAAA,UAEMC,EAAUP,EAAUQ,KAAI,SAACjE,SAAc,CAC3CwE,mBAAAA,EACAX,UAAAA,EACApE,mBAAAA,EACAO,SAAAA,EACA8D,gBAAAA,EACAC,UAAAA,aAGFL,EAAgBQ,gBAAgB,iBAAkBV,GAE3CE,EACJiB,mBAA4BX,GAC5BI,MAAK,SAACC,UACL9E,EAA6C,CAC3CE,mBAAAA,EACAD,KAAM6E,EAASC,QAAQL,KAAI,SAAChD,UAAWA,EAAOzB,QAC9CE,SAAU+D,EAAU/B,YAGvB0C,MAAK,SAAC5E,SAAU,CAAE+E,gBAAiBZ,EAAenE,MACtD,sBCbM,gBACLkE,IAAAA,oBACAC,eAAAA,aAAiB,SAACC,UAAMA,KACxBY,IAAAA,mBACAX,IAAAA,UACApE,IAAAA,mBACAqE,IAAAA,gBACAC,IAAAA,UACAa,IAAAA,UAEMC,EAAQ,CACZL,mBAAAA,EACAX,UAAAA,EACApE,mBAAAA,EACAqE,gBAAAA,EACAC,UAAAA,EACAa,UAAAA,UAGFlB,EAAgBQ,gBAAgB,iBAAkBV,GAE3CE,EACJoB,kBAA2B,CAACD,IAC5BT,MAAK,SAACC,UACLlB,EAAoD,CAClD1D,mBAAAA,EACAD,KAAM6E,EAASC,QAAQL,KAAI,SAAChD,UAAWA,EAAOzB,QAAM0B,YAGvDkD,MAAK,SAAC5E,SAAU,CAAE+E,gBAAiBZ,EAAenE,MACtD,qBC9BM,gBACLkE,IAAAA,oBACAC,eAAAA,aAAiB,SAACC,UAAMA,KACxBY,IAAAA,mBACAX,IAAAA,UACApE,IAAAA,mBACAqE,IAAAA,gBACAC,IAAAA,UACAa,IAAAA,UACAG,IAAAA,WAEMF,EAAQ,CACZL,mBAAAA,EACAX,UAAAA,EACApE,mBAAAA,EACAqE,gBAAAA,EACAC,UAAAA,EACAa,UAAAA,EACAG,WAAAA,UAGFrB,EAAgBQ,gBAAgB,iBAAkBV,GAE3CE,EACJsB,iBAA0B,CAACH,IAC3BT,MAAK,SAACC,UACLlB,EAAoD,CAClD1D,mBAAAA,EAGAD,MC1DsBe,ED2DpB,WC3DsC8C,ED4DtCgB,EAASC,QAAQL,KAAI,SAAChD,UAAWA,EAAOzB,QAAM0B,SC3D3C,IAAI+D,IAAI5B,EAAMY,KAAI,SAACiB,SAAS,CAACA,EAAK3E,GAAM2E,OAAQC,aADtD,IAAuB5E,EAAkB8C,KDgE3Ce,MAAK,SAAC5E,SAAU,CAAE+E,gBAAiBZ,EAAenE,MACtD"}