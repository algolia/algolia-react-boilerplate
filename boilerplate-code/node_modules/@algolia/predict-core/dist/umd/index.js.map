{"version":3,"file":"index.js","sources":["../../src/createZone.ts","../../src/lib/invariant.ts","../../src/lib/warn.ts","../../src/lib/unwrapPrediction.ts","../../src/predict.ts","../../src/lib/computeCartAbandonment.ts","../../src/version.ts"],"sourcesContent":["import { Zone } from './predict';\n\nexport const zoneCounterRef = { current: 0 };\n\nexport type ZoneOptions = {\n  id?: Zone['id'];\n  name: Zone['name'];\n  active?: Zone['active'];\n  happened?: Zone['happened'];\n};\n\nexport function createZone({\n  id,\n  name,\n  active = true,\n  happened = false,\n}: ZoneOptions): Zone {\n  const zone: Zone = {\n    id: id || `${name}-${++zoneCounterRef.current}`,\n    name,\n    active,\n    happened,\n  };\n\n  return zone;\n}\n","/**\n * Throws an error if the condition is not met.\n *\n * The error is exhaustive in development, and becomes generic in production.\n *\n * This is used to make development a better experience to provide guidance as\n * to where the error comes from.\n */\nexport function invariant(\n  condition: boolean,\n  message: string | (() => string)\n): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  /* istanbul ignore next */\n  if (!__DEV__) {\n    throw new Error('Invariant failed');\n  }\n\n  if (__DEV__) {\n    throw new Error(\n      `[Predict] ${typeof message === 'function' ? message() : message}`\n    );\n  }\n}\n","/* eslint-disable no-console, no-empty */\n\nexport const warnCache = {\n  current: {},\n};\n\n/**\n * Logs a warning if the condition is not met.\n * This is used to log issues in development environment only.\n */\nexport function warn(condition: boolean, message: string) {\n  /* istanbul ignore next */\n  if (!__DEV__) {\n    return;\n  }\n\n  if (condition) {\n    return;\n  }\n\n  const sanitizedMessage = message.trim();\n  const hasAlreadyPrinted = warnCache.current[sanitizedMessage];\n\n  if (!hasAlreadyPrinted) {\n    warnCache.current[sanitizedMessage] = true;\n    const warning = `[Predict] ${sanitizedMessage}`;\n\n    console.warn(warning);\n\n    try {\n      // Welcome to debugging Predict.\n      //\n      // This error was thrown as a convenience so that you can find the source\n      // of the warning that appears in the console by enabling \"Pause on exceptions\"\n      // in your debugger.\n      throw new Error(warning);\n    } catch (error) {}\n  }\n}\n","import { type ModelError, type Predictions } from '@algolia/predict';\n\nimport { warn } from './warn';\n\ntype ValueOf<T> = T[keyof T];\n\nfunction isModelError(\n  prediction: Required<ValueOf<Predictions>>\n): prediction is ModelError {\n  return Boolean((prediction as ModelError).error);\n}\n\n/**\n * Unwraps the prediction value, or falls back when it's unavailable.\n *\n * If the model is unavailable, it returns the fallback and triggers a warning.\n */\nexport function unwrapPrediction<TType>(\n  predictions: Predictions | undefined,\n  model: keyof Predictions,\n  fallback: TType\n): TType {\n  const prediction = predictions && predictions[model];\n\n  if (!prediction) {\n    return fallback;\n  }\n\n  if (isModelError(prediction)) {\n    warn(false, prediction.error);\n    return fallback;\n  }\n\n  return prediction.value as unknown as TType;\n}\n","import { computeCartAbandonment } from './lib/computeCartAbandonment';\nimport { invariant } from './lib/invariant';\nimport { unwrapPrediction } from './lib/unwrapPrediction';\nimport { initPredictTools } from './tools';\nimport {\n  type Affinity,\n  type FunnelStage,\n  type OrderValue,\n  type Segment,\n  type UserProfile,\n} from './types';\nimport { version } from './version';\n\nexport type PredictApi = {\n  affinities: Affinity[];\n  cartAbandonment: number;\n  funnelStage: FunnelStage[];\n  orderValue: OrderValue | undefined;\n  segments: Segment[];\n  userProfile: UserProfile;\n  zones: Zone[];\n};\n\nexport type Zone = {\n  id: string;\n  name: string;\n  active: boolean;\n  happened: boolean;\n};\n\ntype EventType = 'UPDATED' | 'ZONE_ADDED' | 'ZONE_REMOVED' | 'ZONE_UPDATED';\ntype Subscriber = (params: PredictApi & { eventType: EventType }) => void;\n\nexport type PredictCoreApi = {\n  getAffinities: () => Affinity[];\n  getFunnelStage: () => FunnelStage[];\n  getOrderValue: () => OrderValue | undefined;\n  getCartAbandonment: () => number;\n  getSegments: () => Segment[];\n  getUserProfile: () => UserProfile;\n  getZones: () => Zone[];\n  update: (nextParams: Partial<PredictOptions>) => void;\n  addZone: (zone: Zone) => Zone;\n  removeZone: (zone: Zone) => void;\n  updateZone: (zone: Pick<Zone, 'id'> & Partial<Zone>) => Zone;\n  subscribe: (subscriber: Subscriber) => () => void;\n};\n\nexport type PredictOptions = {\n  userProfile: UserProfile;\n};\n\nexport function predict(params: PredictOptions): PredictCoreApi {\n  let subscribers: Subscriber[] = [];\n  let userProfile = params.userProfile;\n  const zones: Zone[] = [];\n\n  const update: PredictCoreApi['update'] = (nextParams) => {\n    if (nextParams.userProfile) {\n      userProfile = nextParams.userProfile;\n    }\n\n    notify('UPDATED');\n  };\n\n  const getUserProfile: PredictCoreApi['getUserProfile'] = () => userProfile;\n\n  const getSegments: PredictCoreApi['getSegments'] = () => {\n    return Object.entries(userProfile.segments || {}).reduce<Segment[]>(\n      (acc, segment) => {\n        // We don't use array destructuring because Babel transformations blow\n        // up the bundle size. Once we have more code that requires this syntax,\n        // we can consider upgrading to:\n        // const [type, names] = segment; // not used for bundle optimization\n        const type = segment[0];\n        const names = segment[1];\n        const segmentsInType = names.map<Segment>((name) => ({\n          name,\n          type: type as Segment['type'],\n        }));\n\n        segmentsInType.forEach((segmentInType) => {\n          acc.push(segmentInType);\n        });\n\n        return acc;\n      },\n      []\n    );\n  };\n\n  const getAffinities: PredictCoreApi['getAffinities'] = () => {\n    return unwrapPrediction<Affinity[]>(\n      userProfile.predictions,\n      'affinities',\n      []\n    );\n  };\n\n  const getFunnelStage: PredictCoreApi['getFunnelStage'] = () => {\n    return unwrapPrediction<FunnelStage[]>(\n      userProfile.predictions,\n      'funnel_stage',\n      []\n    );\n  };\n\n  const getOrderValue: PredictCoreApi['getOrderValue'] = () => {\n    return unwrapPrediction<OrderValue | undefined>(\n      userProfile.predictions,\n      'order_value',\n      undefined\n    );\n  };\n\n  const getCartAbandonment: PredictCoreApi['getCartAbandonment'] = () =>\n    computeCartAbandonment(getFunnelStage());\n\n  const getZones: PredictCoreApi['getZones'] = () => zones;\n\n  const addZone: PredictCoreApi['addZone'] = (newZone) => {\n    zones.push(newZone);\n    notify('ZONE_ADDED');\n\n    return newZone;\n  };\n\n  const removeZone: PredictCoreApi['removeZone'] = (zone) => {\n    const zoneIndex = zones.findIndex((x) => x.id === zone.id);\n\n    invariant(\n      zoneIndex !== -1,\n      `Cannot remove zone with ID \"${zone.id}\" because it doesn't exist.`\n    );\n\n    zones.splice(zoneIndex, 1);\n    notify('ZONE_REMOVED');\n  };\n\n  const updateZone: PredictCoreApi['updateZone'] = (zone) => {\n    const zoneIndex = zones.findIndex((x) => x.id === zone.id);\n\n    invariant(\n      zoneIndex !== -1,\n      `Cannot update zone with ID \"${zone.id}\" because it doesn't exist.`\n    );\n\n    const prevZone = zones[zoneIndex];\n    const updatedZone = {\n      id: zone.id,\n      name: zone.name ?? prevZone.name,\n      active: zone.active ?? prevZone.active,\n      happened: zone.happened ?? prevZone.happened,\n    };\n\n    zones[zoneIndex] = updatedZone;\n\n    notify('ZONE_UPDATED');\n\n    return updatedZone;\n  };\n\n  const subscribe: PredictCoreApi['subscribe'] = (subscriber) => {\n    subscribers.push(subscriber);\n\n    return () => {\n      subscribers = subscribers.filter((x) => x !== subscriber);\n    };\n  };\n\n  function notify(eventType: EventType) {\n    subscribers.forEach((subscriber) => {\n      subscriber({\n        eventType,\n        affinities: getAffinities(),\n        cartAbandonment: getCartAbandonment(),\n        funnelStage: getFunnelStage(),\n        orderValue: getOrderValue(),\n        segments: getSegments(),\n        userProfile: getUserProfile(),\n        zones: getZones(),\n      });\n    });\n  }\n\n  // Predict Tools are enabled in development mode, or when the `PREDICT_TOOLS`\n  // environment variable is set. This is useful to use the web extension in\n  // staging environments.\n  if ((__DEV__ || __PREDICT_TOOLS__) && typeof window !== 'undefined') {\n    initPredictTools({\n      version,\n      subscribe,\n      getContext: () => ({\n        affinities: getAffinities(),\n        cartAbandonment: getCartAbandonment(),\n        funnelStage: getFunnelStage(),\n        orderValue: getOrderValue(),\n        segments: getSegments(),\n        userProfile: getUserProfile(),\n        zones: getZones(),\n      }),\n    });\n  }\n\n  const api = {\n    getAffinities,\n    getFunnelStage,\n    getOrderValue,\n    getCartAbandonment,\n    getSegments,\n    getUserProfile,\n    getZones,\n    update,\n    addZone,\n    removeZone,\n    updateZone,\n    subscribe,\n  };\n\n  return api;\n}\n","import { FunnelStage } from '../types';\n\nexport function computeCartAbandonment(funnelStage: FunnelStage[]) {\n  const addToCartFunnelStage = funnelStage.find(\n    (x) => x.name === 'add_to_cart'\n  );\n  const transactionFunnelStage = funnelStage.find(\n    (x) => x.name === 'transaction'\n  );\n\n  if (!addToCartFunnelStage || !transactionFunnelStage) {\n    return 0;\n  }\n\n  const probability =\n    addToCartFunnelStage.probability > transactionFunnelStage.probability\n      ? 1\n      : 0;\n\n  return probability;\n}\n","export const version = '1.4.0';\n"],"names":["zoneCounterRef","current","invariant","condition","message","Error","warn","unwrapPrediction","predictions","model","fallback","prediction","Boolean","error","isModelError","process","env","NODE_ENV","value","_ref","id","name","_ref$active","active","_ref$happened","happened","params","subscribers","userProfile","zones","getUserProfile","getSegments","Object","entries","segments","reduce","acc","segment","type","map","forEach","segmentInType","push","getAffinities","getFunnelStage","getOrderValue","undefined","getCartAbandonment","funnelStage","addToCartFunnelStage","find","x","transactionFunnelStage","probability","getZones","notify","eventType","subscriber","affinities","cartAbandonment","orderValue","update","nextParams","addZone","newZone","removeZone","zone","zoneIndex","findIndex","splice","updateZone","_zone$name","_zone$active","_zone$happened","prevZone","updatedZone","subscribe","filter"],"mappings":"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"}